2024-06-20
maven-compiler-plugin插件每个模块都有
如果将spring-boot-starter-parent依赖作为父依赖，则自动有spring-boot-maven-plugin插件并有repackage属性(打非可依赖包)，一般单个模块的小项目这样使用。
多模块的项目一般不将spring-boot-starter-parent依赖作为父依赖，要打包的模块单独写spring-boot-maven-plugin插件和repackage属性。
如果要打war包添加maven-war-plugin插件设置xml为false属性。

2024-06-06
netstat -tulpn | grep 端口号
lsof -i -P -n | grep LISTEN | grep 端口号
nginx启动后的进程号(pid) nginx.pid文件在哪，是配置在nginx的配置文件中的。
lsof -i -P -n | grep LISTEN | grep nginx的pid 可以查看nginx监听的端口号。
cd /proc/pid，就是应用运行时目录     查看公网ip: curl ipinfo.io

2024-06-01
@MapperScan和@Mapper注解同时存在，且不同包@Mapper会失效
tellhow-db依赖中mybatis-plus配置写了@MapperScan导致@Mapper全部失效。
进入docker容器: docker exec -it 容器名/容器id bash
git clone -b 分支名 url 表示拉取指定分支代码

2024-05-20
不能点击请求之后在调用wx.shareFileMessage,否则报错fail can only be invoked by user
uni.getFileSystemManager()可以处理文件流。

2024-05-10
vim选中所有 ggvG命令
electron依赖安装问题：设置electron镜像源就可以
注意npm的缓存～/.npm/，和~/Library/Caches/的缓存。

2024-04-25
mysql的用户名和密码root 12345678
nginx 403也有可能是文件夹没赋权限。

2024-04-23
配置文件中读取其他配置文件的东西，${x.x}。类中读取配置文件的东西通过配置类。然后注入类。
Knife4j是swagger的封装。（导入依赖-加入相关配置-设置静态资源映射）
设置静态资源映射：继承，重写方法addResourceHandlers设置资源位置addResourceLocations
接口中的方法没有修饰符。注入都加private
配置打印sql查询语句。配置mapper包为debug级别。

2024-04-20
nginx配置任意路径跳转任意网址（在server或location里配）：return https://www.baidu.com
nginx配置任意路径返回状态码，及任意字符串：return 404; return 200 'hello';
react命名规范：
组件，或页面文件夹名都大写。
jsx文件除了，index.jsx全都是大写。组件的引用也是大写。使用也是大写。
vue命名规范：
和react一样，vue使用的时候全部小写，驼峰用-分隔。react使用的时候不变。
java包命名规范：小驼峰。

2024-04-19
web播放rtsp地址的监控摄像头：引入jsmpg.js，通过canvas
new JSMpeg.Player(
          'ws://' + serviceUrl + '/rtsp?url=' + btoa(camera[i].url), //后端的node服务。
          {
            canvas: document.getElementById('canvas' + camera[i].id),
            loop: true, autopaly: true,
          },
);
后端服务：（一个node项目）let RTSP2web = require('rtsp2web')
new RTSP2web({port:10086,audio:false,transportType:'tcp', vf:false //关键参数})
依赖：rtsp2web:"^3.1.7"   真实依赖就是3.1.7。

2024-04-17
一级路由的path以  '/xxx' 开头。二级路由的path没有 '/'
要么就二级路由全写死，‘/一级/二级’
react中二级路由是routes，vue是children。
vue的路径中的redirect实现方式：
在路由中配置redirect（写在最上面）对应的组件，在组件中重定向。
react和vue的Layout布局的区别：
react的路由是否Layout有一个属性去区别，而vue是以路由是否有children来区别。
react的实现方式更易于理解，相当于一个路由可以有两个组件，而vue需要用子路由的
方式去实现另一个组件。
解决history刷新404问题：
nginx配置try_files $uri $uri/ /index.html，或使用hash模式路由。

2024-04-16
搭建纯umi项目，配置在.umirc.ts文件中。
一般 / redirect /index  , /index配置实际的页面。

2024-04-15
el-row不能嵌套使用，否则vue组件无法双向绑定。

2024-04-12
Whitelabel Error Page错误，服务在，接口404，
非Whitelabel Error Page错误，服务不在，服务404。
proxy_pass代理类似于alias，不带代理的路径，root带代理的路径
proxy_pass应该location和proxy_pass最后都带/ 或都不带/。推荐都不带。
通过了nginx代理的请求，502表示服务没启动，或启动的端口不对。

2024-04-07
高院连接内网：无Internet的网络设置ip
手动ipv4，子网前缀长度：16（255.255.0.0)，ipv4地址：141.0.35.239，ipv4网关：141.0.35.254
echarts地图中的data的name数据必须和地图json的name数据完全对应

2024-03-30
nginx配置中也只写死网关的地址。（可以一个服务，多部署，lcfg）
nginx不能监听已经被占用了的端口。
另一种：nginx配置写死各种服务地址（只能有一个服务，fyt）。
nginx端的负载均衡，代理到多个写死地址的服务里。
默认开发环境profiles.active（dev或prd）可以写在application.yml中或maven的配置文件中

2024-03-29
请求头中的host，和远程地址的区别。
optional设置为true影响的是间接依赖，不影响父子间的依赖。
打包：打包问题，可执行，可依赖jar包问题。打包插件中的skip属性(不要设置为true)。
nginx配置中root和alias的区别（重要）。

2024-03-28
git reset（将git add . 操作撤回，如果commit了，只能git revert）
git revert 提交版本号（撤回某一次提交，可以不是最后一次）

2024-03-27
微信小程序开发配置：获取麦克风需要隐私协议，chooseMsgFile，chooseImg不用。
服务器域名 https域名不限端口（要添加端口）
业务域名 限制https的443端口的域名（web-view）
扫普通链接二维码打开小程序 http或https的任意端口路径且通过ICP备案域名

公司业务：
府院通更新版本：修改package.json，vue.config.js中的版本号
府院通电脑端更新app，地址(fyt前端服务器)  /DPS/data1/MinIO/data/fyt/updatePath
府院通消息在/src/layout/componts/StagingMain下面，菜单权限在/src/views/staging/StagingList下面
联村法官APP更新wgt包：mainfest增加版本号，打出wgt包，放到服务器中，去nacos配置中增加版本号

122.51.139.33服务器
启动nginx:
docker run -d -p 80:80 --name nginx -v /home/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /home/docker/nginx/html:/home/docker/nginx/html --restart=always nginx:latest

启动redis:
docker run -d -p 6379:6379 --name redis -v /home/docker/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf -v /home/docker/redis/data:/data --restart=always redis:latest redis-server /usr/local/etc/redis/redis.conf    
(redis.conf中再加--appendonly yes 属性,开启持久化)
docker exec -it redis redis-cli (直接进入redis设置密码)

启动kkfile:
docker run -d -p 8012:8012 --name kkfile --restart=always keking/kkfileview:latest

启动mysql:(未启动)
docker run -d -p 3306:3306 --name mysql -v /home/docker/mysql/lib/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=12345678 --restart=always mysql:5.7

docker运行jar包:
docker run -d -p 8080:8080 --name xxx-biz -v /home/docker/xxx-biz:/home/docker/xxx-biz --restart =always java:openjdk-8u111 java -jar /home/docker/xxx-biz/xxx-biz.jar


2024-09-13
开发过程：创建数据库-创建表-添加记录。创建工程-引入依赖。创建配置文件-指定数据库路径。创建工程启动类。
创建操作表的实体类。创建Mapper-并继承BaseMapper-并指定对应实体类。  
MP逻辑删除:在表里面添加标志位的字段，并配置。
MP分页:创建配置类，配置分页。调用分页的方法。

2024-09-23
注意如果<mirrorOf>*</mirrorOf>会覆盖项目pom.xml中的私服地址
安装jar包：mvn install:install-file -DgroupId=com.aspose.words -DartifactId=aspose-words -Dversion=19.5 -Dpackaging=jar -Dfile=aspose-words-19.5.jar
rabbitmq:messagequeue(消息队列)将同步的事件驱动改为异步的消息驱动。解耦，异步，削峰。

2024-09-30
查看java进程命令：jsp
可以实时的显示当前正在执行的进程的CPU使用率命令: top

找到进程方式：
ps -ef | grep xxx
netstat -tulpn ｜ grep 端口号 和 lsof -i:端口号

--------------------------------------------------------------------------------------------
《java基础》
1.java有几种基本数据类型，String是不是基本数据类型，他们有哪些区别？
有8种数据类型，4种整数型：byte、short、int、long，2种浮点型：float、double，1种字符类型：char1种布尔型：boolean，String不是基本数据类型，String是一个类，类是引用数据类型。1个字节等于8位，int是4个字节，32位。

2.equals与==的区别？
==如果比较基本数据类型，比较的是值，如果比较引用类型，比较的是对象的地址值。equals不能比较基本数据类型，只能比较比较两个对象的地址值。

3.为什么重写equals方法就一定要重写hashCode方法？
如果只重写equals方法，不重写hashCode方法，就有可能导致a.equals(b)这个表达式成立，但是hashCode却不同。会造成一个完全相同的对象会存储在hash表的不同位置。也会导致Set集合不能去重。

4.列出几种常见的异常？
NullPointerException-空指针异常，ClassCastException-类型转换异常，IllegalArgumentException-非法参数异常，ArrayIndexOutOfBoundsException-数组下标越界异常，StringIndexOutOfBoundsException-字符串下标越界异常。ArithmeticException-算术异常。InterruptedException（阻塞线程被其它线程interrupt打断，会抛出该异常）。

5.String和StringBuffer和StringBuilder的区别？
StringBuffer：可变字符序列、(增删)效率较高、线程安全，StringBuilder：可变字符序列、(增删)效率最高、（不保证同步）线程不安全。

6.Java中finalize方法的作用是什么？
在Java中，finalize方法是Object类中定义的一个方法，其作用是在对象被垃圾回收器回收之前执行一些清理操作。finalize方法在对象即将被回收时自动调用，可以用来释放对象占用的资源、关闭文件或网络连接、取消注册的事件等清理工作。

7.NoClassDefFoundError 和 ClassNotFoundException的区别？
NoClassDefFoundError编译时成功时，但是在运行时找不到该类的定义时，则虚拟机会抛出该异常。
ClassNotFoundException当程序使用类加载器动态加载 Class 文件时，如果没有找到该类，则虚拟机会抛出该异常

8.Exception和Error的区别？
Exception和Error都是继承于Throwable 类。Error是java程序运行中不可预料的异常情况。Exception可以使用try catch捕获处理。

9.Java异常处理完成后，Exception对象会发生什么变化？
Exception对象会在下一个垃圾回收过程中被回收掉。

10.throw与throws的区别？
thorws：主要在方法的声明后使用，表示方法中不处理异常，而交给调用方处理。
throw直接抛出一个异常，throw new ArithmeticException("除数不能为零");

11.marshalling和demarshalling
Marshalling（序列化）是将内存中的对象状态转化为适合传输或存储的格式（如字节流、JSON、XML），以便进行网络通信、持久化存储或跨平台/语言交互操作。Demarshalling（反序列化）则是其逆过程，将序列化数据还原为原始对象。
序列化实现方式包括：Java原生序列化：实现Serializable接口，使用JVM内置机制。第三方库：如protobuf、Avro、Jackson、Gson，提供更灵活、高效的解决方案。

12.Servlet体系？
Servlet根据客户端请求生成响应内容并将其传给服务器，服务器将响应返回客户端。
GenericServlet 实现了 Servlet 接口，为 Servlet 提供了一些通用的功能，但它本身并不直接处理 HTTP 请求和响应。
HttpServlet 继承自 GenericServlet，专门用于处理 HTTP 请求和响应。HttpServlet 提供了对 HTTP 请求方法的更直接的支持，如 doGet()、doPost() 等。
Servlet 的生命周期分为四个阶段：实例化、初始化、处理请求、服务终止。init()，service()，destroy()是 Servlet 生命周期的方法，分别对应 Servlet 生命周期的后三个阶段，方法中的代码在处于对应的生命周期时被执行。
与UNIX和DOS命令中的管道类似，你也可以将多个servlet以特定顺序链接起来。在servlet链中，一个servlet的输出被当作下一个servlet的输入，而链中最后一个servlet的输出被返回到浏览器。

13.sendRedirect()和forward()方法有什么区别？
sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。

14.ResourceBundle类？
类路径：java.util.ResourceBundle，用来读取项目中后缀为properties的配置文件的类。

15.java流体系？
字节流示例：文件复制。InputStream 及其子类，FileInputStream。
字符流示例：文件内容读取和写入。Reader 及其子类，Writer 及其子类，FileReader。
缓冲流示例：高效文件复制。BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter
处理流示例：DataInputStream, DataOutputStream, FileReader, FileWriter
转换流示例：InputStreamReader：将字节输入流转换为字符输入流，OutputStreamWriter：将字符输出流转换为字节输出流。

16.抽象类和接口的区别?
接口只能做方法声明，抽象类中可以作方法声明，也可以做方法实现。
接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
抽象类和接口都是用来抽象具体对象的，但是接口的抽象级别最高。
抽象类可以有具体的方法和属性，接口只能有抽象方法和不可变常量。
抽象类主要用来抽象类别，接口主要用来抽象功能。

17.接口是否可继承接口? 抽象类是否可实现接口? 抽象类是否可继承实体类?
接口可以继承(extends)接口。抽象类可以实现接口。抽象类可继承具体类也可以继承抽象类。

18.try {}里有一种return语句，那么紧跟在这个try后旳finally{}里旳 code 什么时候被执行?
会执行，在 return 前执行。 

19.什么是静态方法？
使用静态方法方便快捷，不用创建对象就能直接调用，省时省力，而且，静态方法是“共享”的，不占用每个对象的内存空间，所以更加节省内存。
虽然静态方法好用，但也不能滥用，它比较适合用在那些不依赖对象状态、可以独立执行的功能上，比如工具类的方法，同时，因为静态方法是属于类的，所以要注意线程安全，特别是在修改静态变量时。

20.interrupt方法？
将在sleep（阻塞）状态的线程，变为就绪状态。

21.wait()？
与synchronized配合锁对象一起使用，调用锁对象.wait()方法，将该线程变进入等待队列，等待otify(),notifyAll()无时间限制的sleep，也会被interrupt打断，再检查synchronized同步锁，如果锁被释放了则变为就绪状态。

22.join()？
join()同样是Thread中的一个方法，调用join的线程拥有优先使用CPU时间片的权利，其他线程需要等待join()调用线程执行结束后才能继续执行，探索其底层会发现，它的底层是通过wait()进行实现，因此它也需要处理异常。

23.sleep()与wait()的区别？
JDK1.8 sleep() wait() 均需要捕获 InterruptedException 异常；
sleep() 方法可以在任何地方使用；wait() 方法则只能在同步方法或同步代码块中使用；
sleep() 会休眠当前线程指定时间，释放 CPU 资源，不释放对象锁，休眠时间到自动苏醒继续执行；wait() 方法放弃持有的对象锁，进入等待队列，当该对象被调用 notify() / notifyAll() 方法后才有机会竞争获取对象锁，进入运行状态。

24.java多态的实现机制？
父类的引用变量指向子类的实例对象。

25.构造方法的作用是什么？
主要作用是完成对类对象的初始化工作。

26.在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？
帮助子类做初始化继承来的属性。

27.hashCode？
hashCode的作用时获取哈希值，也称散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。

28.Java接口隔离原则和单一原则如何理解？
单一原则：一个类只负责一项职责。隔离原则：不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

29.Java中是否有goto？如果没有，如何跳出当前的多重嵌套循环？
没有。通过异常处理跳出循环。通过标志变量，多层都break出循环。通过添加标签，在最外层循环添加一个标签，在最里层通过break+标签  跳出循环。break是跳过整个循环 。continue是跳过本次循环。

30.Java中创建对象的多种方法？
通过new关键字，我们可以调用类的构造函数来创建一个新的对象实例。
使用反射机制：Class.forName("Person").getConstructor(String.class).newInstance("glm")
通过实现Cloneable接口并重写clone方法，再调用clone方法实现对象的克隆。
使用使用工厂方法。工厂方法模式是一种设计模式，通过定义一个用于创建对象的接口，该接口里一个方法没有方法体，返回值是要创建的对象，子类去实现该接口，并重写该方法，在里面创建对象并返回。通过多态调用该方法，得到对象。

31.final修饰的类的特点？
不能被继承。Sting就是一个被final修饰的类。还可以修饰变量，被final修饰的变量就是一个常量，只能赋值一次。

32.设计模式？
创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
结构型模式：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

33.单例模式？
饿汉单例模式：private static Singleton instance = new Singleton();让单例类的构造方法变成私有。让外部通过只能通过get方法读取。只涉及到读操作(线程是安全的)。
懒汉单例模式：在get方法中判断该对象是否为空,为空我们再去实例化,否则直接返回该对象。但是这样是线程不安全的，加锁（用同步代码块包起来）。
内部类创建的单例模式。

34.指令重排序线程不安全问题？
构造对象分三步：1，创建出对象(建好房子)，2，构造对象(装修房子)，3，将生成的地址赋值给对象引用(拿到钥匙).在多线程情况下,线程调度无序,那么某个线程可能会拿到一个没有构造好的对象(啥也没有,属性都是默认的)。所以为了保证线程拿到完整的对象,我们需要用volatile关键字修饰单例类的唯一对象。

35.工厂模式？
如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建某个对象的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。
工厂方法：工厂负责一种类型，再增加其他的类型只需要添加一个工厂类以及具体的图形类即可，符合了开放-封闭原则

36.抽象工厂和工厂方法的区别？
抽象工厂是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。接口里多个方法，返回值不同的要创建的对象。

37.值对象模式
值对象的本质是“封装数据”，就是vo，例：UserVo。

38.Dao模式？
public class EmpDaoImpl extends BaseDao implements EmpDao{}
BaseDao里面有注册驱动，连接数据库，executeQuery，executeUpdate等方法。
EmpDao里面都是接口，saveEmp，updateEmp，selectEmp等。
EmpDaoImpl继承BaseDao，并实现EmpDao，实现saveEmp方法，通过super.executeUpdate()插入到数据库中。

39.foreach和for循环的区别
foreach虽然能遍历数组或者集合，但是只能用来遍历，无法在遍历的过程中对数组或者集合进行修改。
而for循环可以在遍历的过程中对源数组或者集合进行修改。(但是删除会导致元素前移，有个元素遍历不到，可以使用i--解决)

40.foreach为什么不能增加或删除集合？
foreach循环会转换成迭代器方式，所以遍历下⼀个元素之前会验证modCount（是集合的修改次数）与expectedModCount（是迭代器中集合的修改次数）是否相同。
在循环或迭代时，会首先创建一个迭代实例，这个迭代实例的expectedModCount 赋值为集合的modCount.
每当迭代器使⽤ hashNext() / next() 遍历下⼀个元素之前，都会检测 modCount 变量与expectedModCount 值是否相等，相等的话就返回遍历；否则就抛出异常【ConcurrentModificationException】，终⽌遍历
如果在循环中添加或删除元素，是直接调用集合的add,remove方法【导致了modCount增加或减少】，但这些方法不会修改迭代实例中的expectedModCount，导致在迭代实例中expectedModCount 与 modCount的值不相等，抛出ConcurrentModificationException异常
但迭代器中的remove,add方法，会在调用集合的remove,add方法后，将expectedModCount 重新赋值为modCount，所以在迭代器中增加、删除元素是可以正常运行的。
--------------------------------------------------------------------------------------------
《集合》
1.什么是快速失败和安全失败？
快速失败是指在多线程访问情况下，使用迭代器遍历集合数据时，其他线程对集合进行了修改，此时则会抛出
Concurrent Modification Exception异常。
而安全失败则是，在其他线程想要修改集合数据时，将集合“原件”进行“复印”，使得其他线程修改的是“复印件”，而不影 响其他线程对原集合数据的迭代访问，从而达到安全失败的效果。
安全失败的好处：
在对于数据要求并非特别严格，允许数据出现延迟刷新时，安全失败可以保护程序不面临崩溃，而是付出相对较小的代价，解决数据安全问题。类似于论坛的评论等。
ArrayList所实现的AbstractList接口，会对程序进行快速失败，而CopyOnWriteArrayList所实现的list接口，则是提供安全失败。HashMap会对程序进行快速失败，ConcurrentHashMap则是提供安全失败.

2.集合体系？
分为单列集合（类似于js中的数组）和双列集合（类似于js中的对象），单列集合接口Collection,又分为List（可重复数组）接口和Set（不可重复数组）接口,实现类包括ArrayList,LinkedList,HashSet,LinkedHashSet,TreeSet，双列集合接口Map,实现类包括HashMap, LinkedHashMap, TreeMap,Properties。

3.数组和链表？
数组更具下标查找时间复杂度为o(1),通过关键字查找时间复杂度为o(n)。
链表插入和删除时间复杂度为o(1),而查找需要遍历链表,时间复杂度为o(n)。

4.二叉查找树和平衡二叉查找树？
二叉查找树(也叫二叉搜索树)是高度任意的二叉树，有左边的一定比右边的小，有顺序，所以方便查找。时间复杂度为o(logn)
平衡二叉查找树也叫平衡二叉树(AVL)，左右子树的高度差不超过1。

5.hashMap工作原理？
由数组和链表的数据结构组成。
插入和查找数据时将key和value封装成一个node节点，然后根据key的hashCode除以桶的长度得到一个下标，这个下标下面挂着的是一条链表，新数据比较key，相同则覆盖value值，不相同则插在最后面。
在jdk8以后，如果链表的节点数大于8个，链表会变成红黑树结构。当红黑树上的节点小与6个，又会变成单向链表。核心目的都是提升和均衡搜索效率。
hashMap的resize（也叫rehash）表示数组的默认长度（默认长度16）快用完时，会发生扩容（扩容因子是0.75）。要从新计算元素在数组中的位置。

6.红黑树的理解？
每个节点不是黑色就是红色，根节点和叶节点是黑色的。
红色的节点一定是有两个黑色的孩子节点。
从某节点到其所有后代叶节点的路径上，黑色节点都是一样。
红黑树是一个不完美的平衡二叉树。

7.HashMap和Hashtable有什么区别？
HashMap线程不安全,HashTable线程安全(Hashtable 中的方法大多是Synchronize的，而HashMap中的方法在一般情况下是非Synchronize的。)
解决hash冲突方式不同(地址冲突):HashTable中,不轮链表长度是否大于8,都是以链表方式存储。
Hashmap是允许key和value为null值的，HashTable键值对都不能为空。

8.Java如何权衡是使用无序的数组还是有序的数组？
有序数组最大的好处在于查找的时间复杂度是O(logn)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。

9.HashSet 和 TreeSet 的区别
HashSet 和 TreeSet 都是常用的 Set 接口的实现类。
HashSet 是由数组加链表来实现的。由于哈希表的无序性，HashSet 中的元素也是无序的。
TreeSet是SortedSet接口的唯一实现类 通常是红黑树来实现的。TreeSet 中的元素是有序的，且默认是自然排序，也可以通过比较器进行自定义排序。要重写compareTo方法，当返回值是0时，说明2个对象内容相等，就不加入集合。
时间复杂度：HashSet接近于O(1)，TreeSet是O(logn)

10.请说明 Collection和Collections的区别?
Collection是Java集合框架中集合类的一个基本接口。
Collections是Java集合框架提供的一个辅助类，包含了各种对集合类进行操作的静态方法。这些方法包括排序、查找、替换、复制、打乱顺序等。Collections类的静态方法可以对各种Collection集合进行操作，使用起来非常方便。

11.Java面试八股之WeakHashMap的工作原理？
使用弱引用来管理键，这种特性使得WeakHashMap在处理大量临时数据时非常有用，因为它能够自动释放不再使用的键所占用的空间。弱引用的对象在垃圾收集时总是会被回收，而软引用的对象则在内存不足时会被回收。

12.List, Set, Queue, Map 四者的区别？
List 是可重复有序的集合。常用的实现类有 ArrayList 和 LinkedList。
Set 是不可重复的无序集合。常用的实现类有 HashSet、LinkedHashSet 和 TreeSet。
Queue 是一种队列（先进先出）的数据结构。用的实现类有 LinkedList 和 PriorityQueue。
Map是一种键值对的映射集合。常用的实现类有 HashMap、LinkedHashMap 和 TreeMap。

13.Java 中 LinkedHashMap 和 PriorityQueue 之间的区别？
LinkedHashMap 是一个哈希表，加个双向链表保证顺序（默认按访问顺序，也可以设置按插入访问的顺序）。时间复杂度是o(1),基于hash查找实现的快时间复杂度。使用场景适合缓存，历史记录。
PriorityQueue的数据结构是二叉树实现的一个小根堆。队列中的元素按照优先级，通过 compareTo() 方法或提供的 Comparator进行排序。默认情况下，队列顶部（peek() 返回的元素）是当前优先级最高的元素。
poll()（移除并返回优先级最高的元素）、peek()（查看但不移除优先级最高的元素）
优先级最高的元素就是第一个元素。
PriorityQueue优先级队列就是一个自定义顺序的数组。时间复杂度是o(n)
TreeSet的时间复杂度是 o(logn)

14.请简述ArrayList 与 LinkedList 的区别？
ArrayList 维护的是一个动态数组，LinkedList维护的是一个双向链表.

15.Java 中如何对集合进行排序？
Collections.sort() 方法是 Java 中对集合排序的最常用方式。它可以对 List、Set 和数组进行排序，支持自然排序和自定义排序。
利用TreeSet排序 new TreeSet<Object>(实现Comparator，重写compare方法) 。

16.Comparable 和 Comparator 的区别？
接口所在的包不同：comparable：java.lang.Comparable；Comparator：java.util.Comparator
比较逻辑不同：Comparable：内部比较器，必须在类上实现该接口通过固定字段进行比较；Comparator：是外部比较器，在方法中通过lambda表达式实现接口就可以了。
排序方法不同：Comparable重写方法compareTo(T o）；Comparator重写方法compare(T o1, T o2)
在Collections.sort()中使用不同：一个参数，默认是Comparable自然排序，二个参数，需要传入Comparator外部排序
排序规则数量限制不同：Comparable唯一字段排序，Comparator可以有多个字段排序

17.Java中ArrayList和HashMap的默认大小?
ArrayList：默认初始容量是 10 个元素,它会自动扩容，通常扩容后的容量是原来的 1.5 倍
HashMap：默认初始容量是 16 个元素，当元素数量超过 16 × 0.75 = 12 个时，HashMap 会自动扩容，通常扩容后的容量是原来的 2 倍。

18.Vector与ArrayList区别
Vector线程安全、ArrayList线程非安全。Vector是同步的。

19.HashMap 的长度为什么是 2 的 N 次方呢？
采用长度为 2 的幂次方作为容量可以有效地减少哈希冲突的概率
并且在扩容时重新哈希的操作更为高效。这种设计能够保证元素的分布均匀，提高 HashMap 的性能。

20.简述怎么确保一个集合不能被修改 ？
使用 JDK中java.util.Collections 类，unmodifiable*** 方法赋值原集合。

21.什么是 Hash 碰撞？怎么解决哈希碰撞？
将哈希表中每个槽的位置变成一个链表，当多个键的哈希值相同时，将它们存储在同一个链表中。

22.Java 的 CopyOnWriteArrayList 和 Collections.synchronizedList 有什么区别？分别有什么优缺点？
CopyOnWriteArrayList 是一个线程安全的 List 实现，特性就是写时复制。
每次对 List 的修改操作（如 add, set, remove）都会复制创建一个新的底层数组。读操作不需要加锁，写操作需要加锁。
Collections.synchronizedList是一个包装方法，可以将任何 List 转换为线程安全的版本，它会对每个访问方法（如 get, set, add, remove）进行同步（加 synchronized 锁），从而保证线程安全。

23.为什么 Java 的 ConcurrentHashMap 不支持 key 或 value 为 null？
为了避免混淆和潜在的并发问题，在并发修改或删除操作时，也可能导致多线程下不一致的状态，增加调试和维护的难度。

24. IdentityHashMap？
IdentityHashMap是使用==比较两个键是否为同一对象，而不是equals，当需要存储大量可引用比较的对象时可以节省空间。

25.阻塞队列？（线程间的通讯，控制那个线程执行）
当阻塞队列是空是，从队列中获取元素的操作会被阻塞。take()一直等， poll()等指定的时间
当阻塞队列是满时，从队列中添加元素的操作会被阻塞。put()一直等， offer()等指定的时间
--------------------------------------------------------------------------------------------
《多线程》
1.多线程的创建方式？
继承Thread类。实现Runable接口。new Thread()，并使用匿名内部类。
如果期望创建一个线程，并关注这个线程产生的放回结果，使用Callable比较合适
通过FutureTask的get()方法来获取Callable的返回值，如果此时还有返回值，get方法就会阻塞

2.start方法和run方法？
start()方法用来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法。而直接调用run()方法，仅仅只是调用了一个类里的方法，其本质上还是在当前线程中执行的，因此只有使用start()方法来调用$un()方法才能实现真正的多线程。

3.线程的 sleep()方法和 yield()方法？
执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态。

4.详细阐述Java进程和线程的区别 ？
进程之间互不干扰，相互独立。一个进程能拥有多个线程。
进程——资源分配的最小单位，线程——程序执行的最小单位。

5.线程的几种状态？
就绪(Runnable):线程准备运行，不一定立马就能开始执行。 
运行中(Running)：进程正在执行线程的代码。 
等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。 
睡眠中(Sleeping)：线程被强制睡眠。 
I/O阻塞(Blocked on I/O)：等待I/O操作完成。 
同步阻塞(Blocked on Synchronization)：等待获取锁。 
死亡(Dead)：线程完成了执行。

6.同步代码块和同步方法的区别？
同步代码块：使用synchronized关键字，并指定一个对象作为锁。可以使用任何对象(包括this关键字)作为锁。
同步方法：直接在方法签名中使用synchronized关键字，无需指定锁对象。锁对象为该方法所属对象。

7.在监视器(Monitor)内部,是如何做线程同步的?
监视器和锁在Java虚拟机中是一块使用的，监视器监视一块同步代码块，确保只有一个线程执行同步代码块，每一个监视器都和一个对象相关联，线程在获取锁之前不允许执行同步代码块。

8.解释什么是死锁( deadlock )？
死锁<DeadLock>: 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。这些永远在互相等待的进程称为死锁进程。

9.如何确保N个线程可以访问N个资源同时又不导致死锁？
让所有的线程都是以同样的顺序加锁和释放锁。

10.请问Java方法可以同时即是static又是synchronized的吗?
可以，相当于这个锁是这个类，和this有区别。

11.Java中多线程同步怎么理解？
多个线程共享一个资源的时候，保证不会混乱。
在Java程序运行时环境中，JVM需要对两类线程共享的数据进行协调：
保存在堆中的实例变量，保存在方法区中的类变量。这两类数据是被所有线程共享的。（程序不需要协调保存在Java 栈当中的数据。因为这些数据是属于拥有该栈的线程所私有的。）

在java虚拟机中，每个对象和类在逻辑上都是和一个监视器相关联的。
对于对象来说，相关联的监视器保护对象的实例变量。
对于类来说，监视器保护类的类变量。（如果一个对象没有实例变量，或者一个类没有变量，相关联的监视器就什么也不监视。）
为了实现监视器的排他性监视能力，java虚拟机为每一个对象和类都关联一个锁。代表任何时候只允许一个线程拥有的特权。线程访问实例变量或者类变量不需锁。
但是如果线程获取了锁，那么在它释放这个锁之前，就没有其他线程可以获取同样数据的锁了。（锁住一个对象就是获取对象相关联的监视器）

12.java中sleep方法和wait方法的五个区别？
sleep 方法和 wait 方法都是用来将线程进入休眠状态的，并且 sleep 和 wait 方法都可以响应 interrupt 中断，也就是线程在休眠的过程中，如果收到中断信号，都可以进行响应并中断，且都可以抛出 InterruptedException 异常。

wait 方法必须配合synchronized 一起使用。 而 sleep 可以单独使用，无需配合 synchronized 一起使用。
wait 方法属于 Object 类（某个锁）的方法，而 sleep 属于 Thread 类的方法
sleep 方法必须要传递一个超时时间的参数，且过了超时时间之后，线程会自动唤醒。
wait 表示永久休眠，直到另一个线程调用了 notify 或 notifyAll 之后，休眠的线程才能被唤醒。也就是说 sleep 方法具有主动唤醒功能，而不传递任何参数的 wait 方法只能被动的被唤醒。
wait 方法会主动的释放锁，而 sleep 方法则不会。
调用 sleep 方法线程会进入 TIMED_WAITING 有时限等待状态，而调用无参数的 wait 方法，线程会进入 WAITING 无时限等待状态。

13.唤醒阻塞的线程？
唤醒wait的线程：lock.notify();
唤醒sleep的线程：t1.interrupt(); // 中断线程，唤醒它catch (InterruptedException e)处理唤醒的线程。

14.简述Java中CycliBarriar和CountdownLatch有什么区别？
CountdownLatch一个线程等待其他线程执行完之后再执行，相当于加强版的join，在初始化CountDownLatch是需要设定计数器的数值（计数器数据不一定跟线程数相同，但是一定计数器的值一定是要大于等于线程数，一个线程中可以进行多次扣减。当计数器扣减至0时才可继续向下执行）new CountDownLatch(5);countDownLatsh.await();
线程扣减1，当扣到0时，countDownLatsh.countDown(); countDownLatsh就被唤醒了。等待所有玩家准备好了，开始。

CycliBarriar让一组线程到达某个屏障，然后被阻塞，一直到最后一个线程到达屏障，然后屏障开放，所有被阻塞的线程继续执行，计数器与线程数相等。
到达后cyclicBarrier.await();进入阻塞状态，当所有线程都到达后，所有被阻塞的线程会继续执行。

15.简述volatile 类型变量提供什么保证？
volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供原子性和互斥性。
volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主 存中读取。
volatile提供了有序性，在多线程环境下，线程的指令可能会被重排序，这可能导致某些指令的执行顺序发生变化。但是，使用volatile关键字修饰的变量会禁止指令重排序，保证其赋值操作的有序性。

16.简述如何调用 wait（）方法的？使用 if 块还是循环？为什么？
用循环，因为if 块，同时唤醒两个删除线程，两个都被唤醒时，唤醒后直接执行唤醒的逻辑（这是虚假唤醒），而应该唤醒后再执行判断是否还应阻塞。

17.虚假唤醒？
用 if 块判断调用 wait（）唤醒后直接执行唤醒的逻辑，而应该唤醒后再执行判断是否还应阻塞。

18.解释什么是多线程环境下的伪共享（false sharing）？
现代CPU为了提高访问内存的速度，会将内存分成一系列的缓存行，通常大小为64字节，并且以缓存行为单位将数据从主存（RAM）加载到CPU缓存中。
False Sharing（伪共享）是并发编程中的一个性能问题，它发生在多个线程访问并修改相互独立的变量时，这些变量恰好位于同一个缓存行（Cache Line）内。
当一个线程修改了一个缓存行内的数据时，处于同一缓存行的其他数据也会被标记为无效，导致其他线程在访问自己的变量时不得不重新从主存中加载整个缓存行。

19.什么是线程局部变量？
在Java中，ThreadLocal类提供了这样的功能。通过使用ThreadLocal，你可以为每个使用该变量的线程提供一个独立的变量副本。这样，每个线程都可以独立地读取和写入自己的变量副本，而不会与其他线程的变量副本产生冲突。
可以使用ThreadLocal来存储与当前用户会话相关的数据，如用户身份、权限等。
在数据库操作中，每个线程可能需要维护自己的数据库连接。使用ThreadLocal可以为每个线程提供独立的数据库连接实例，从而避免连接共享带来的问题。
每个线程可能都需要维护自己的事务上下文。使用ThreadLocal可以确保每个线程都能独立地管理自己的事务状态。

20.Java 中 ++ 操作符是线程安全的吗?
++ 操作符本身并不是线程安全的。当你在一个多线程环境中对共享变量使用 ++ 操作符时，可能会遇到数据不一致的问题，因为 ++ 操作符通常不是原子的。
多线程环境中安全地增加变量的值，你可以使用 AtomicInteger 类，它提供了线程安全的原子操作。

21.你有哪些多线程开发良好的实践？
给线程命名，这样可以帮助调试。
最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。
如果可以，更偏向于使用 volatile 而不是 synchronized。效率更高
尽可能使用更高层次的并发工具而非wait和notify()来实现线程通信,如BlockingQueue,Semeaphore
优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。
考虑使用线程池

22.SimpleDateFormat 是线程安全的吗?
不是，因为里面维护了calendar对象的引用，如果多个线程同时争抢calendar对象，则会出现各种奇怪的问题，
将 SimpleDateFormat 定义为局部变量；
使用 synchronized 加锁执行；
使用 Lock 加锁执行（和解决方案 2 类似）；
使用 ThreadLocal；
使用 JDK 8 中提供的 DateTimeFormat。

23.线程安全的集合类？
Vector，Hashtable，ConcurrentHashMap，CopyOnWriteArrayList

24.请简述ReadWriteLock 和 StampedLock ？
ReadWriteLock 是Java提供的一个接口。当一个线程持有写锁时，其他线程无法获取读锁和写锁。当一个线程持有读锁时，其他线程可以同时获取读锁，但无法获取写锁。
StampedLock 也支持多个线程同时获取读锁，只允许一个线程获取写锁。
与 ReadWriteLock 不同的是，StampedLock 还提供了一个乐观读锁（Optimistic Read Lock），即不阻塞其他线程的写操作，但在读取完成后需要验证数据的一致性。StampedLock 适用于读远远大于写的场景，并且对数据的一致性要求不高，例如统计数据、监控系统等。

25.简述 Synchronized 的原理 ？
当一个线程进入了 synchronized 代码块或方法时，其他试图进入该同步区域的线程必须等待，直至拥有锁的线程执行完毕并释放锁。这确保了在同一时间只能有一个线程访问共享资源，避免了竞态条件和数据不一致的问题。
一旦一个线程在 synchronized 块中修改了共享变量的值，其他随后进入同步区域的线程可以看到这个更改。这是因为解锁过程会将工作内存中的最新值刷新回主内存，而加锁过程则会强制从主内存中重新加载变量的值。

可重入锁（Reentrant Lock）： synchronized 实现的锁是可重入的，允许同一个线程多次获取同一个锁，而不会造成死锁。这意味着线程在持有锁的情况下可以再次获取相同的锁，而不会被阻塞。
排它锁/互斥锁/独占锁： synchronized 实现的锁是排它的，也就是说，在任意时刻只有一个线程能够获取到锁，其他线程必须等待该线程释放锁才能继续执行。这确保了同一时刻只有一个线程可以访问被锁定的代码块或方法，从而保证了数据的一致性和完整性。

26.Monitor（监视器）？
Monitor 是一种同步机制，负责管理对象的锁。每个对象都与一个 Monitor 相关联。当一个线程尝试进入一个被synchronized修饰的代码块或方法时，它会尝试获取对象的 Monitor。如果 Monitor 处于无锁状态，则当前线程会尝试将其锁定；如果 Monitor 已经被其他线程锁定，则当前线程会进入阻塞状态，直到持有锁的线程释放锁。

27.java 为什么wait(),notify(),notifyAll()必须在同步（Synchronized）方法/代码块中调用？
调用wait()就是释放锁，释放锁的前提是必须要先获得锁，先获得锁才能释放锁。
notify(),notifyAll()是将锁交给含有wait()方法的线程，让其继续执行下去，如果自身没有锁，怎么叫把锁交给其他线程呢

28.Java 如何实现多线程之间的通讯和协作？
共享变量与同步机制。
wait()、notify() 和 notifyAll()。
阻塞队列。
java.util.concurrent 包下的一系列高级并发工具类来简化线程间通信。
BlockingQueue：线程安全的队列，常用于生产者-消费者模式。
CountDownLatch：允许一个或多个线程等待其他线程完成某些操作。
CyclicBarrier：多个线程在某个点上相互等待，直到所有线程到达该点。
Semaphore：用于控制对资源的访问许可。
Exchanger：用于两个线程之间交换数据。

29.为什么Synchronized 是非公平锁？
Synchronized 是非公平锁以及悲观锁。

30.公平锁和非公平锁？
公平锁是指当一个线程释放锁之后，等待时间最长的线程将获得锁。
非公平锁是指多个线程获取锁的顺序是不确定的，不一定按照申请锁的顺序来获取锁。

31.独占锁（也叫排它锁/互斥锁）与共享锁？
独占锁：同一时间，一把锁只能被一个线程获取。
共享锁：同一时间，一把锁可以被多个线程获取。

32.可中断锁与不可中断锁？
不可中断锁：一旦线程申请了锁，就必须等待获取锁后方能执行其他的逻辑处理。
可中断锁：在获取锁的过程中可以中断获取，不需要非得等到获取锁后再去执行其他逻辑；

33.可重入锁？
就是一个线程在获取到了一个对象锁后，即便持有的锁还没释放，仍然可以再次获取该锁。不可重入锁这种情况下会发生死锁！
由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全释放成功。

34.悲观锁与乐观锁？
悲观锁： synchronized 实现的锁属于悲观锁，因为它默认情况下假设会发生竞争，并且会导致其他线程阻塞，直到持有锁的线程释放锁。悲观锁的特点是对并发访问持保守态度，认为会有其他线程来竞争共享资源，因此在访问共享资源之前会先获取锁。
在乐观锁的思想中，认为数据访问冲突的概率很低，因此不加锁直接进行操作，但在更新数据时会进行版本比对，以确保数据的一致性。
乐观锁的原理主要基于版本号或时间戳来实现。在每次更新数据时，先获取当前数据的版本号或时间戳，然后在更新时比对版本号或时间戳是否一致，若一致则更新成功，否则表示数据已被其他线程修改，更新失败。

35. ReentrantLock？
ReentrantLock是一种同时拥有独占式、可重入、可中断、公平/非公平特性的同步器！

36.请对比下 Synchronized 和 ReentrantLock 的异同 ？
synchronized 可用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用在代码块上。
ReentrantLock 在使用之前需要先创建 ReentrantLock 对象，然后使用 lock 方法进行加锁，使用完之后再调用 unlock 方法释放。
获取锁和释放锁的机制不同：synchronized 是自动加锁和释放锁的，而 ReentrantLock 需要手动加锁和释放锁。
锁类型不同：synchronized 是非公平锁，而 ReentrantLock 默认为非公平锁，也可以手动指定为公平锁。
响应中断不同：ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断。
底层实现不同：synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。

37.什么是锁消除和锁粗化？
锁消除是编译器或运行时系统在代码优化阶段，通过静态分析或动态优化检测到某些情况下不需要进行同步的代码块，并将其对应的锁操作去除的优化技术。
锁粗化通过减少锁竞争的频率来提高程序的性能。当编译器检测到代码中多个连续的、对同一个对象进行加锁和解锁的操作时，会将这些操作合并为一个更大的锁操作，从而减少锁竞争的次数。

38.AQS框架？
AQS通过一个volatile变量state来管理同步状态。这个变量可以被视为资源的数量，当state为0时，表示没有线程占用资源；当state大于0时，表示资源已经被占用。
AQS使用FIFO（先进先出）队列来管理等待获取资源的线程。队列中的每个节点都代表一个等待线程。当某个线程请求共享资源时，如果发现资源已被占用，它会被放入队列的尾部等待；当资源被释放时，会唤醒队列头部的线程。

39.创建线程池？
ExecutorService threadPool = Executors.newFixedThreadPool(7);// 创建固定数量的线程池。
ExecutorService threadPool = Executors.newCachedThreadPool();// 创建不固定数量的线程池。
threadPool.execute(lamda表达式执行的线程)

40.自旋？
自旋是指在多线程编程中，当线程尝试获得某个锁时，如果该锁已经被其他线程占用，线程会一直循环检查该锁是否被释放，直到获取到该锁为止。这个循环等待的过程被称为自旋。

41.Lock 接口对比同步它有什么优势？
整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁。

42.Java 中用到的线程调度算法是什么？
Java 中用到的线程调度算法是时间片轮转+优先级调度算法。在优先级调度中，每个线程都被赋予一个优先级，并且线程的调度是基于它们的优先级来进行的。具有更高优先级的线程比较低优先级的线程更容易被调度，因此它们的执行可能会更频繁。当多个线程具有相同的优先级时，则按照其先来先服务的原则进行调度。优先级从 1 到 10，10 表示最高优先级，1 表示最低优先级。

43.关于java中static关键字修饰的属性无法被序列化的解释？
被static修饰的属性是所有类共享的。

44.Java中的原子操作是什么？
Java中的原子操作是指一组操作要么全部执行成功，要么全部不执行，不会出现部分执行成功的情况。在Java中，可以通过使用synchronized关键字或者使用java.util.concurrent.atomic包下的原子类来实现原子操作。

45.简述什么是Java竞态条件？你如何发现并解决竞态条件？
是指多个线程同时访问和修改共享资源时可能出现的不一致状态。
通过适当的同步机制、原子操作或使用并发容器等方式来确保多线程环境下的数据一致性。

46.如果你的Serializable类包含一个不可序列化的成员，会发生什么？你是如何解决的？
会抛出异常，将其声明为静态(static)的。或瞬态transient)的。

47.什么是 Java 的 Timer？
Timer.schedule(TimerTask task, long delay) 在指定的延迟之后执行任务。类似setTimeout
Timer.scheduleAtFixedRate(TimerTask task,long delay,long period)周期性地执行任务。类似setIntval

48.线程池？
创建若干个线程对象，备用。提高线程的利用率。提高程序相应速度。可以控制最大的并发数。
new ThreadPoolExecutor(线程个数，最大个数，最大个数的空闲时间，时间的单位，等待队列，线程工厂（用默认工厂），拒绝策略（直接抛异常）)
ExecutorService.commit(()->{执行多线程代码})

49.难点？
多线程获取数据，让所有线程执行完了，在执行。将数据插入数据库，发消息。处理失败情况。
--------------------------------------------------------------------------------------------
《jvm虚拟机》
1.简述Java堆的结构？什么是堆中的永久代(Perm Gen space)?
JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。
永久代主要存在类定义，字节码，和常量等很少会变更的信息。并且永久代不会发生垃圾回收，如果永久代满了或者超过了临界值，会触发完全垃圾回收（Full Gc）
在java8中，已经移除了永久代，新加了一个叫做元数据区的native内存区。
元空间和永久代类似，都是对JVM中规范中方法的实现。 不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。类的元数据放入native memory（也就是元空间），字符串池和类的静态变量放入java堆中。

2.描述行( serial )收集器和吞吐量( throughput )收集器的区别 ？
行收集器，也就是Serial GC，它是一个单线程的垃圾收集器。
吞吐量收集器，也称为Throughput GC或Parallel GC，它使用多个线程来并行地进行垃圾收集。

3.在Java中对象什么时候可以被垃圾回收？
无引用指向。
循环引用：即使是两个或多个对象相互引用，但它们不再被其他活跃的引用或根对象引用时，这些对象也可以被视为垃圾并回收。Java的垃圾收集器可以识别这种情况。
从可达性分析：gcroot的对象被用作起点，gcroot通常包括活跃线程的栈帧中的本地变量、静态字段和特定的方法区域。从这些根出发，GC将标记所有可以访问到的对象。
Java还提供了弱引用（WeakReference）和软引用（SoftReference）等机制。弱引用的对象在垃圾收集时总是会被回收，而软引用的对象则在内存不足时会被回收。

4.JVM的永久代(就是java8中的元空间或方法区)中会发生垃圾回收么？
元空间主要用来存储JVM加载的类信息、常量以及方法数据。 这种垃圾回收通常发生在进行全局垃圾收集（Full GC）的时候。 不过，需要注意的是，类的卸载和常量池的清理并不是特别频繁，因为它们的生命周期通常跟应用程序的生命周期一样长。

5.解释静态变量在什么时候加载？编译期还是运行期？
静态变量是类级别的变量，在Java中，它们随类一起加载。在运行期被加载和初始化。
类加载：首先，当Java程序运行时，Java虚拟机(JVM)通过类加载器加载包含静态变量的类。这一步涉及到查找字节码并从类的全路径名生成一个Class对象。
链接：加载后，类进入链接阶段，这个阶段验证类中的字节码，为静态变量分配内存，并且可能将变量设置为默认值，如null、0或false。
初始化：在链接阶段之后，类的初始化阶段开始。在这个阶段，静态变量按照它们在代码中出现的顺序显式初始化，如果它们有初始化表达式的话。此外，如果有静态初始化块（static block），它也会在这个时候执行。

6.JVM自身会维护缓存吗？
方法区（或元空间）：存储了类的结构信息，包括运行时常量池、字段和方法数据，以及方法的代码。这可以看作是一种缓存机制，因为它避免了每次执行时重新加载和解析类文件。
字符串池（String Intern Pool）：优化字符串存储和重用
即时编译器（JIT）的代码缓存：将热点代码（即频繁执行的代码）编译成本地机器代码
堆中的缓存结构：应用级的数据缓存，用于存储经常访问的数据对象。
Biased Locking偏向锁：优化对象锁的一种机制。减少无竞争访问同步块的锁开销。在对象头中缓存线程ID
类加载器缓存：类加载器在加载类时，会缓存类信息，加快了下次类加载的速度。

7.请详细列举 JVM有哪些参数，分别如何设置与调优？
java -Xms512m -Xmx2048m -jar your-application.jar
初始堆大小 -Xms512m 
最大堆内存大小 -Xmx2048m 
年轻代大小 -Xmn768m
栈设置：每个线程的栈大小 -Xss1m

-XX:NewRatio=2 # 设置老年代与年轻代的比例为2，即老年代是年轻代大小的两倍
如果你的应用长时间运行并且主要进行老年代垃圾回收，增大这个比例可能会有帮助。

-XX:SurvivorRatio=8 # 设置Eden区与一个Survivor区的大小比例为8，即Eden是Survivor的8倍
适当调整这个比例可以优化对象在年轻代的存活时间，减少老年代的压力。

-XX:+PrintGCDetails         # 打印详细的GC日志
-XX:+PrintGCDateStamps      # 在GC日志中包含时间戳
-Xloggc:gc.log              # 指定GC日志输出文件

-XX:MaxGCPauseMillis=200 # 设置垃圾回收的最大停顿时间为200毫秒
这对于需要低延迟的应用特别有用，如实时交互系统。

-XX:PretenureSizeThreshold=1048576 # 设置大对象（大于1MB）直接在老年代分配
这有助于减少大对象在年轻代中的分配和复制，特别是对于那些频繁创建和销毁大对象的应用。

-XX:+UseParallelGC        # 启用并行垃圾回收器
-XX:ParallelGCThreads=4   # 设置垃圾回收时使用的线程数为4

-XX:MetaspaceSize: 指定JVM的元空间（Metaspace）初始大小，适用于JVM 8及之后的版本。
-XX:MaxMetaspaceSize: 指定JVM的元空间最大大小，适用于JVM 8及之后的版本。

-XX:+UseSerialGC: 使用串行垃圾回收器。单线程，适用于较小的应用。
-XX:+UseParallelGC: 使用并行垃圾回收器。多线程，适用于多核机器。
-XX:+UseConcMarkSweepGC（CMS）: 使用并发标记清除垃圾回收器。低停顿时间，适合交互式应用。
-XX:+UseG1GC (G1) 它是适用于大堆内存并且需要低延迟的场景，替代 CMS。

8.并发和并行？
并发（Concurrency）和并行（Parallelism）并发同一个时间段内交替执行，而并行同一个时间段内同时执行。

9.Serial 与 Parallel GC之间的不同之处？
相同点新生代采用标记-复制算法，老年代采用标记-整理算法。区别是串行与并行执行垃圾收集工作。

10.怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？
System.getProperty("os.arch") 

11.java的堆空间
新生代（Young Generation）：占1/3
新生代存储新创建的对象。进行minor gc
通常细分为三个区域：伊甸园区（Eden Space）(占1/3的8/10)和两个幸存者区（Survivor Space）(分别占1/10)。
对象在伊甸园区创建，并在达到某些条件后移动到幸存者区。
老年代（Old Generation）： 占2/3
老年代存储生命周期较长的对象。进行 full gc 才会被清理
新生代经过多次垃圾收集后幸存下来的对象会被晋升到老年代。

12.System.gc() 或 Runtime.getRuntime().gc()能保证 GC 执行吗？
不能，这只是建议，JVM 有权忽略它，具体是否执行取决于垃圾收集器的策略和当前内存状态。

13.怎么获取 Java 程序使用的内存？堆使用的百分比？
Runtime runtime = Runtime.getRuntime();
long maxMemory = runtime.maxMemory(); // 获取最大可用内存
long totalMemory = runtime.totalMemory();// 获取当前已分配的总内存 
long freeMemory = runtime.freeMemory();// 获取当前空闲内存
long usedMemory = totalMemory - freeMemory;// 计算已使用的内存

14.简述JVM内存区域总共分为哪两种类型 ？
非堆内存是 JVM 使用的其他内存区域，包括：
方法区（Method Area）： 存储类结构、方法、常量池等信息，是堆外的逻辑部分。方法区在Java8以后被包含在元空间中。
栈（Java Stack）： 每个线程的私有内存区域，存储线程运行时的栈帧，包括局部变量和方法调用信息。
本地方法栈（Native Method Stack）： 用于执行本地方法，存储本地方法的调用状态。
程序计数器（PC Register）： 每个线程的私有区域，存储当前正在执行的指令地址。

15.即时编译器（Just-In-Time Compiler, JIT）？
即时编译器（JIT）的代码缓存：将热点代码（即频繁执行的代码）编译成本地机器代码，以提高执行性能。

16.逃逸分析（Escape Analysis）？
优化技术，用于分析对象的生命周期和作用域，以决定是否将对象分配在栈上而非堆上。

17.执行引擎？
解释器：在运行时将字节码编译为机器码
即时编译器：将热点代码（即频繁执行的代码）编译成本地机器代码，以提高执行性能。
垃圾回收器：垃圾回收

18.解释GCrooot 包括哪些？
栈中的引用变量
方法区中的类静态属性引用
方法区中的常量引用
本地方法栈中的引用

19.简述JVM 分代收集算法 ？
新生代（Young Generation）。新生代通常会频繁地执行垃圾收集（也称为Minor GC）。
对象最初在Eden区分配。Minor GC时，存活的对象从Eden区和一个Survivor区复制到另一个Survivor区，同时未被引用的对象将被清理。对象每经历一次复制，年龄增加，当达到一定年龄阈值后，如果仍然存活，它们将被晋升到老年代。

老年代（Old Generation）老年代的垃圾收集频率较低但通常更耗时，因为它包含的对象都是难以被回收的。老年代的垃圾收集通常称为Major GC或Full GC。

永久代（PermGen）或元空间（Metaspace，Java 8引入）
用于存放JVM加载的类信息、常量以及静态资源，这部分区域与对象的生命周期不直接相关。
在Java 8中，永久代已被元空间替代，元空间使用本地内存，从而避免了固定大小的永久代带来的问题。

20.请列举JDK1.8 和 1.7做了哪些JVM优化 ？
JDK 1.7: 包含了多种垃圾收集器，如Parallel GC, CMS, Serial GC等。
JDK 1.8: 加入了几项垃圾收集的优化，比如G1垃圾收集器的改进。G1成为更多推荐的替代老年代垃圾收集器，特别是在具有大内存、多核服务器的环境下。G1垃圾收集器旨在降低Full GC的停顿时间，并提高性能。

JDK 1.7: String常量池已从方法区移到堆中，这是JDK 1.7的变更。
JDK 1.8: 继续优化堆中的String常量池，减少重复字符串的内存占用，提高了字符串操作的性能。

JDK 1.8: 引入了基于调用的动态编译（profile-guided optimization），使得JIT编译器可以根据程序运行时的实际性能数据进行优化，进一步提高执行效率。

JDK 1.8 加强了类加载机制的性能，改善了锁机制的实现，包括对synchronized锁的优化，使得Java程序在多线程环境下运行得更快。

21.内存泄漏和内存溢出有什么区别 ？
内存泄漏是指程序在申请内存后，无法进行垃圾回收的内存。在Java中，内存泄漏常见的情况是集合类持有对象引用而未能释放
内存溢出是指程序在运行过程中，因为需求的内存超过了系统可供分配的最大内存，导致申请新内存失败。这通常会引发错误或异常，如Java中的OutOfMemoryError。

22.常见的内存泄漏？
如果注册了监听器或回调而未适当取消注册，那么这些监听器或回调可能会持续存在，导致所有相关对象无法被垃圾回收。
非静态内部类和匿名内部类会隐式持有对其外部类实例的引用。
如果内部类的实例被长时间持有，那么外部类的实例也不能被回收。

23.栈上分配和内存逃逸
对于不逃逸（一个对象在方法外部没有被引用）的对象，编译器可以选择在栈上分配内存，避免堆分配，从而提高性能。

24.请简述Minior GC、MajorGC与Full GC ？
Minor GC当新生代的内存不足时触发，这通常发生在应用频繁创建新对象时。
MajorGC当老年代的内存不足时触发，这通常是因为对象从新生代晋升而导致老年代填满。
Full GC是指对整个Java堆（新生代、老年代）以及方法区（或元空间）的完全垃圾收集。可以由多种原因触发，包括但不限于：
显式调用System.gc()；JVM内存分配失败，如老年代或方法区（元空间）空间不足；JVM启动参数触发，例如进行某些特定的性能监测操作。

25.解释什么是双亲委派机制？它有什么作用？
加载任务委托给它的父加载器。父加载器再向它的父加载器委托，一直到达顶层的启动类加载器（Bootstrap ClassLoader）。
避免类的重复加载。防止核心API被随意篡改。

26.Java8默认使用的垃圾收集器是什么？
Java8默认的垃圾收集器是Parallel Garbage Collector，也称为Parallel GC。

27.请解释CMS、G1垃圾回收器中的三色标记 ？
黑色： 这个对象的所有引用都已经扫描过。 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。
灰色： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。
白色： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。

28.简述JVM什么是TLAB（本地线程分配缓存）？
可以把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在Java堆中预先分配一小块内存,这就是TLAB（Thread Local Allocation Buffer，本地线程分配缓存） 。大大加速了内存分配的同时避免了多线程竞争共享堆内存时的同步开销。
虚拟机通过 -XX:UseTLAB 设定它的。

29.Javad的AOT(Ahead-Of-Time)
Java 的 AOT（Ahead-Of-Time，预编译）是一种在程序运行之前，将 Java 字节码直接编译为本地机器码的技术。

30.线上排错 生成堆栈快照配置
启动时指定dump文件路径，-XX:HeadDumpPath=/usr/jdk/dump，将dump文件拿到分析工具中去看。
内存升高时获取dump文件：
jcmd <pid> GC.heap_dump /usr/jdk/cach.hprof 或 jmap -dump:file=/dumpfile.hprof 【pid】
分析dump文件
Memory Analyzer Tool、JProfiler、VisualVM等或一些在线分析工具（HeapHero）。https://heaphero.io
gc日志：-Xlog:gc*=info:file=/path/app.log:filesize=100M,filecount=5

--------------------------------------------------------------------------------------------
《spring》
1.Spring框架的核心模块？
核心容器（Core Container）：
Spring-core：提供了框架的基本组成部分，包括IoC（控制反转）和DI（依赖注入）功能，以及一些基础工具类如类型转换服务、资源加载器等。
Spring-beans：提供了BeanFactory接口，这是工厂模式的经典实现，是Spring用来创建、配置和管理Java对象（称为Bean）的主要机制。它包含了Bean的定义、解析、装配和生命周期管理等功能。
Spring-context：建立在Core和Beans模块基础之上，提供了更高级别的抽象，如ApplicationContext接口。它引入了AOP（面向切面编程）支持，事件传播（ApplicationEventPublisher）等，并能够与Spring的其他模块集成。
AOP模块（Spring AOP）：
提供了面向切面编程的实现，允许定义方法拦截器和切入点，将诸如事务管理这样的横切关注点与业务逻辑解耦，实现了代码的模块化和重用。
Spring-JDBC：简化了JDBC的使用，提供了一个JDBC抽象层，封装了异常处理和资源管理，支持模板化操作和RowMapper接口以简化结果集映射。
Spring-TX：提供了对事务管理的支持，包括编程式和声明式事务管理，可以与各种事务管理API（如JTA、JDBC）及事务管理器无缝集成。
Spring-ORM：为流行的ORM框架（如MyBatis等）提供了集成支持，使它们能够遵循Spring的通用事务和DAO异常层次结构。
Web模块（Spring Web）：
Spring-web：提供了基本的面向Web的集成特性，如多部分文件上传、Servlet监听器以及Web相关的应用上下文。它为与其他Web框架（如Struts、JSF）的集成提供了支持。
Spring-webmvc（Spring MVC）：实现了模型-视图-控制器（MVC）设计模式，为构建Web应用程序提供了全面的解决方案，包括处理器映射、视图解析、数据绑定、异常处理等。

2.什么是IOC？什么是DI？
把对象交给Spring管理, 就是IoC思想。也就是说 Spring 是一个"控制反转"的容器
什么是控制反转呢? 也就是控制权反转。 什么的控制权发生了反转? 获得依赖对象的过程被反转了。
也就是说, 当需要某个对象时, 传统开发模式中需要自己通过 new 创建对象, 现在不需要再进行创 建, 把创建对象的任务交给容器, 程序中只需要依赖注入 (DI)就可以了。
容器在运行期间, 动态的为应用程序提供运行时所依赖的资源，称之为依赖注入（DI）。IoC 是一种思想，也是"目标"，而思想只是⼀种指导原则，最终还是要有可行的落地方案，而 DI 就属于 具体的实现。所以也可以说, DI 是IoC的一种实现。

3.什么是声明式事务？
Spring的声明式事务就是采用声明的方式来处理事务，用在Spring配置文件中声明式的处理事务来代替代码式的处理事务。这样的好处是，事务管理不侵入开发的组件，具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要更改事务管理，也只需要在定义的配置文件中修改配置即可，在不需要事务管理的时候，只要在配置文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便。

4.如何实现声明式事务？
在application.xml配置文件中进行事务配置，SpringAOP的原理配置的。
使用@Transactional注解方式。在application.xml配置文件中进行事务配置(通知Spring容器对注解@Transactional的Bean处理)，@Transactional注解可以添加到类上(表示所有的方法都加入事务管理)，也可以在具体的方法加上注解@Transactional。一般用在EmpDaoImpl的方法上。

5.注解事务的原理？
当spring容器启动的时候，发现有@EnableTransactionManagement（在spring配置类上是否有）注解，此时会拦截所有bean的创建，扫描看一下bean上是否有@Transaction注解（类、或者父类、或者接口、或者方法中有这个注解都可以），如果有这个注解，spring会通过aop的方式给bean生成代理对象，代理对象中会增加一个拦截器，拦截器会拦截bean中public方法执行，会在方法执行之前启动事务，方法执行完毕之后提交或者回滚事务。

6.解释Spring AOP里面的关键词 ？
target（目标类）：需要被代理的类。
Joinpoint（连接点）：Spring中连接点指的就是被拦截到的方法
Advice（通知）：AOP在连接点上如何执行的增强处理，有before（前置），after（后置），afterReturning（最终），afterThrowing（异常），around（环绕）
Pointcut（切点）：在程序中主要体现为书写切入点表达式
连接点相当于数据库中的记录，而切点相当于查询条件。切点和连接点不是一对一的关系，一个切点可以匹配多个连接点。
切面（Aspect）：切面由切点和通知组成
织入（Weaving）：把切面应用到目标对象来创建新的代理对象的过程，Spring采用动态代理织入（在运行期为目标类添加通知生成子类的方式）
Proxy（代理）：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类。
AOP：面向切面编程，对面向对象编程的一种补充。
例：四个方法都要添加日志，横切一刀，将这个面看作一个对象，操作这个对象，这个对象就是切面， 拦截哪些方法（连接点？）？通过自定义注解标记目标方法（新建注解包，自定义一个注解类，给这个注解添加一些源注解，例如加在方法上的，运行时的。就可以使用注解了）。新建切面包，新建一个切面类，加上切面注解并交给ioc管理，并加上切面注解。在这个类中添加方法（切点）并加上切点的注解写自定义的注解就找到了，这个就是切点（找连接点的）。再添加一个方法（通知）并加上通知注解写上面切点的方法名，就会执行通知方法。这个通知方法里第一个参数就是连接点对象。

7.Spring的Advice的执行顺序？
Around before...，before....，连接点对象返回完，after....，Around after...

8.Spring Bean 生命周期?
实例化（Instantiation）：Spring 容器根据配置元数据（XML 配置文件、Java 配置类或注解）创建 Bean 实例。
属性注入（Dependency Injection）：Spring 容器将依赖注入到 Bean 实例中，完成属性的设置。
初始化（Initialization）：在 Bean 实例化和属性注入完成后，Spring 容器会调用 Bean 的初始化方法，进行一些自定义的初始化操作。
就绪使用（Ready for Use）：Bean 被初始化后，进入就绪状态，可以被应用程序使用。
销毁（Destruction）：当 Spring 容器关闭时，会调用 Bean 的销毁方法，进行一些自定义的销毁操作。
@PostConstruct和@PreDestroy注解，自定义 Bean 的初始化和销毁方法。
InitializingBean和DisposableBean是Spring 提供的两个接口，分别用于定义初始化和销毁方法。
@Bean(initMethod = "customInit", destroyMethod = "customDestroy")用于定义初始化和销毁方法。

9.BeanFactory和ApplicationContext的区别？
ApplicationContext继承了BeanFactory，ApplicationContext在BeanFactory基础上对功能进行了扩展（比如国际化，时间发布，AOP集成、任务执行和资源管理等）。

10.什么是BeanFactory？
BeanFactory是Spring框架中的一个接口，定义了一种工厂模式的设计，用于管理和装配Java对象。它充当了一个对象工厂，可以在应用程序中创建和管理对象。
BeanFactory在初始化容器时，并未实例化Bean，直到第一次访问某个Bean时才实例目标Bean。
ApplicationContext则在初始化应用上下文时就实例化所有单实例的Bean，相对应的，ApplicationContext的初始化时间会比BeanFactory长一些。

11.Spring Bean几种作用域？
singleton：单例作用域，所有对该Bean的请求都返回同一个Bean实例。
prototype：原型作用域，每次请求时都创建一个新的Bean实例。
request：请求作用域，每个HTTP请求都会创建一个新的Bean实例，该Bean实例仅在当前请求内有效。
session：会话作用域，每个HTTP会话都会创建一个新的Bean实例，该Bean实例仅在当前会话内有效。
application：全局作用域,一个bean 定义对应于单个ServletContext 的生命周期。
websocket： HTTP WebSocket 作用域,一个bean 定义对应于单个websocket 的生命周期。

12.Spring框架中的bean是线程安全的吗？
默认就是线程不安全的。但是对于开发中大部分的bean，其实都是无状态的，不需要保证线程安全。
无状态：表示这个实例没有属性对象，不能保存实数据，是不变的类。比如：controller、service、dao。
有状态：表示实例是有属性的对象，可以保存数据，是线程不安全的，比如：pojo。
但是如果要保证线程安全，可以将bean的作用域改为prototype，比如像Model View。
ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。
线程同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。ThreadLocal采用了“空间换时间”的方式。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。

13.spring基于xml注入bean的几种方式？
使用类的无参数构造函数来创建<bean id="user" class="xxx"></bean>
使用静态工厂创建:创建类后，需要再创建一个静态工厂<bean id="user" class="xxx" factory-method="getUser">
使用实例工厂创建:创建类后，需要再创建一个普通工厂<bean id="userFactory" class="xxx"></bean>
<bean id="user" factory-bean="userFactory" factory-method="getUser"></bean>

14.spring为bean的属性注入值方式?
set方法注入:对于基本数据类型，或者是Java的包装类型（比如String），使用value注入值，而对于引用类型，则使用ref，传入其他bean的id。
构造器注入:得为类提供包含参数的构造方法
静态工厂注入
实例工厂注入
注解注入：@Autowired或者@Resource这两个注解进行依赖注入，为基本数据类型或者是Java的封装类型（比如String）赋值呢？这时候可以使用@Value注解。

15. spring启动过程？
加载配置文件：Spring会读取并加载应用程序中的配置文件，如XML配置文件、注解配置等，包括配置数据库连接、事务管理、AOP 配置等。。
实例化IOC容器：Spring会实例化一个IOC容器，用于管理应用程序中的各种Bean对象。
扫描组件：Spring会扫描应用程序中的所有组件，包括Bean、Controller、Service等。
实例化Bean对象：Spring会根据配置文件或注解实例化各种Bean对象，并将其放入IOC容器中。
注入依赖：Spring会自动注入Bean对象之间的依赖关系，即将一个Bean对象注入到另一个Bean对象中。
初始化Bean对象：Spring会调用Bean对象的初始化方法，如@PostConstruct注解标注的方法。
启动应用程序：最后，Spring会启动应用程序，执行各个Bean对象的逻辑，完成应用程序的初始化过程。

16.Spring 循环依赖解决方案？
Spring利用三级缓存解决循环依赖流程。


17.Spring无法解决的循环依赖？
延迟加载@Lazy注解。
对你需要注入的bean是使用setter注入（或字段注入），而不是构造函数注入。

18.Spring bean注入流程？
类实例化 -> 属性注入 -> 初始化(执行@PostConstruct注解的方法) -> (如果有需要)生成代理对象 -> 使用

19.简述spring的自动装配？
@Autowired根据指定的装配规则，不需要明确指定，Spring自动将匹配的属性值注入bean中。
@Qualifier("beanName"): 当存在多个相同类型的Bean时，可以使用@Qualifier注解来明确指定要注入哪一个Bean。
constructor: 如果使用构造器注入，Spring将根据类型来装配构造器的参数。

20.Spring框架中都用到了哪些设计模式？
单例模式（Singleton Pattern）：Spring Bean的默认作用范围是单例的
Spring使用工厂模式通过BeanFactory和ApplicationContext来创建Bean实例。
Spring AOP（面向切面编程）主要使用了代理模式，来实现方法拦截和增强功能。
Spring中的JdbcTemplate和RestTemplate等模板类都是模板方法模式的典型应用。

21.Spring框架中事件？
上下文更新事件（ContextRefreshedEvent）：
ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在ConfigurableApplicationContext 接口中使用 refresh() 方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有 Singleton Bean 被预实例化，ApplicationContext容器已就绪可用。
上下文开始事件（ContextStartedEvent）：
当使用 ConfigurableApplicationContext （ApplicationContext子接口）接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。此时可以调查的数据库，或者可以在接受到这个事件后重启任何停止的应用程序。
上下文停止事件（ContextStoppedEvent）：
当使用 ConfigurableApplicationContext 接口中的 stop() 停止 ApplicationContext 时，发布这个事件。可以在接受到这个事件后做必要的清理的工作
自定义事件：
自定义事件继承ApplicationEvent.监听器事件实现ApplicationListener.写配置类用ioc容器注册事件.调配置类发布事件

22.@Component 和 @Bean 的区别是什么？
作用对象不同：@Component 注解作用于类，而 @Bean 注解作用于方法、
@Component 通常是通过路径扫描来自动侦测以及自动装配到 Spring 容器中。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean 告诉了 Spring 这是某个类的实例，当我们需要用它的时候还给我。
@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring 容器时，只能通过 @Bean 来实现。

23.Autowire 和 @Resource 的区别？
@Autowire 默认按类型装配，默认情况下必须要求依赖对象必须存在，如果要允许 null 值，可以设置它的 required 属性为 false。
@Resource 默认按名称装配，当找不到与名称匹配的 bean 时才按照类型进行装配。名称可以通过 name 属性指定，如果没有指定 name 属性，当注解写在字段上时，默认取字段名，当注解写在 setter 方法上时，默认取属性名进行装配。

24.Spring事务中的隔离级别有哪几种？
Spring的事务隔离级别是用于控制事务并发访问数据库时的行为。Spring框架提供了五个事务隔离级别，分别是：
DEFAULT（默认）：使用数据库默认的事务隔离级别。在大多数情况下，这等同于使用READ_COMMITTED级别。
READ_UNCOMMITTED（读取未提交数据）：最低的隔离级别，允许一个事务读取另一个事务未提交的数据。这种隔离级别可能会导致脏读、不可重复读和幻读问题。
READ_COMMITTED（读取已提交数据）：保证一个事务只能读取到已经提交的数据，避免脏读问题。但是在并发情况下，可能会导致不可重复读和幻读问题。
REPEATABLE_READ（可重复读取）：保证一个事务在多次读取同一数据时，能够得到一致的结果。在该隔离级别下，其他事务不能修改当前事务已经读取的数据，避免了不可重复读问题。但是仍然可能出现幻读问题。
SERIALIZABLE（可串行化）：最高的隔离级别，确保并发事务之间不会发生任何并发问题。它通过强制事务串行执行来避免脏读、不可重复读和幻读问题。但是这种隔离级别的性能较低，一般情况下不建议使用。
可以通过在@Transactional注解中设置isolation属性来指定事务的隔离级别。

25.简述Spring事务中有哪几种事务传播行为？
在a service中依赖b service,a中方法调了b中方法,a和b方法中都有事务，此时产生事务传播行为（b方法中的事务传播到了a方法中的事务中）
相融：合并为一,挂起:两个事务相互独立,内部事务新开一个(要解决同步)，嵌套：内部事务改成保存点的形式、外部事务不变。
required：(默认传播行为)。11相融，01当前事务。//
supports：11相融，01无事务。
not_supported：以非事务执行。11外界挂起，自己非事务。01无事务。//
mandatory:总是以事务方式执行，11相融。10抛异常。01抛异常。//
never: 11抛异常。01抛异常。//
nested：11嵌套，01当前事务。//
requires_new：11挂起，01当前事务。//
REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务。//
SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。//
MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。//
REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。//
NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。//
PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。//
NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则创建新事务。//

26.Spring框架提供的容器有哪些？
BeanFactory和ApplicationContext。
BeanFactory就是一个管理Bean的工厂，它主要负责初始化各种Bean，并调用它们的生命周期方法
ApplicationContext是BeanFactory的子接口，也被称为应用上下文。

27.简述BeanDefinition的作用 ？
BeanDefinition 用于保存 Bean 的相关信息，包括属性、构造方法参数、依赖的 Bean 名称及是否单例、延迟加载等，它是实例化 Bean 的原材料，Spring 就是根据 BeanDefinition 中的信息实例化 Bean。
BeanDefinition 是一个接口，它有多个实现类，这些实现类分别描述不同类型的 Bean。

28.解决同名类？
通过@ComponentScan进行排除。通过加@Primary注解解决。自定义TypeExcludeFilter。
@Primary注解可以用来指定当存在多个同类型的Bean时，哪个Bean应该被优先考虑。
这边有个特别需要注意的细节点，因为TypeExcludeFilter是要排除bean的，因此他注入的时机至少要在其他bean注入之前，具体来说就是在容器上下文refresh执行之前，就得完成注入。在refresh之前执行的扩展点有很多，我们就挑一个，我们以实现ApplicationContextInitializer为例。

29.控制反转(IoC)的实现机制
Spring 中的 IoC 的实现原理就是简单工厂模式加反射机制。

30.依赖注入的基本原则?
应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配。

31.构造器注入和 Setter方法注入的区别?
最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。
构造器注入可注入不可变对象(final类型的)；
构造函数注入一般用于注入不可变的依赖对象，而setter注入用于注入可变的依赖对象。
因为依赖对象是在构造方法中执行的，而构造方法是在对象创建之初执行的，因此被注入的对象在使用之前，会被完全初始化，这也是构造方法注入的优点之一。

32.Spring如何处理线程并发问题?
使用@Async注解：通过@Async注解将一个方法标记为异步执行，这样该方法会在一个新的线程中运行，不会阻塞调用它的线程。
使用Executor和TaskExecutor接口：Spring提供了Executor和TaskExecutor接口，它们是任务执行器，可以用于执行异步任务。通过注入一个Executor或TaskExecutor实例，可以更灵活地控制任务的执行。
使用@Scheduled注解：Spring的@Scheduled注解用于支持定时任务，在指定的时间间隔内自动执行某个方法。
使用ThreadLocal变量：ThreadLocal变量可以用来存储线程局部变量，每个线程都拥有该变量的一个副本，从而避免了多线程并发访问的问题。
使用同步锁：通过synchronized关键字或Lock接口来实现同步锁，可以防止多个线程同时访问某个共享资源，从而解决并发问题。
使用事务管理：Spring提供了强大的事务管理功能，可以保证在并发环境下数据的一致性和完整性。

33.Spring中如何注入一个java集合？
@Bean
public List<String> myList() {
   return Arrays.asList("item1", "item2", "item3");
}
或者xml方式，<list></list>注入。

34.什么是bean的自动装配？
在使用 Spring 配置 bean 时,我们都要给配置的 bean 的属性设置一个值,如果不手动设置则都是空。而自动的好处就在于，我们不用手动去设置一个值，spring 会在上下文中自动寻找并装配合适的值。

35.Spring中bean有几种装配机制？
在xml中显式配置；
在java中显式配置；
隐式的bean发现机制和自动装配。

36.自动装配又有几种机制？
byName：根据属性名自动装配。
byType：根据属性类型自动装配
constructor: 如果使用构造器注入，Spring将根据类型来装配构造器的参数。
注解实现自动装配@Autowired和@Resource

37.@Autowired和@Resource的区别？
@Autowired为Spring提供的注解，@Resource为java提供的注解
@Autowired 默认通过 byType 的方式实现，如果有多个对象，则通过 byName 查找，如果都找不到或不唯一，则报错；此时可以用@Qualifier指定（指定名字）唯一的bean对象
@Resource 默认通过 byName 的方式实现，如果找不到名字或不唯一， 则通过 byType 实现！如果两个都找不到或不唯一，就会报错

38.可以在Spring中注入一个null 和一个空字符串吗？
@Autowired(required = false)  @Value("")

39.如何在 spring 中启动注解装配？
默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置 <context：annotation-config/> 元素在 Spring 配置文件中启用它。

40.Spring 中的 @Required 注解的作用?
表示该属性必须要被设置（必须要被注入）。不过@Required注解已被废弃，不再推荐使用。Spring推荐使用构造器注入来确保必需的依赖能被正确的设置。这种方式更为直观，并且可以利用Java的类型安全特性，而不需要额外的运行时检查。

41.简述Spring @ControllerAdvice ？
@ControllerAdvice 是 Spring 框架提供的一个注解，用于定义全局的异常处理器和全局数据绑定。它通常用于集中处理应用程序中的异常，并提供统一的异常处理逻辑。

42.FactoryBean?
工厂Bean是BeanFactory中的一个特殊的Bean。FactoryBean接口很简单，就提供了三个方法getObject、getObjectType、isSingleton。
FactoryBean的真正目的是让开发者自己去定义那些复杂的bean并交给spring管理，如果bean中要初始化很多变量，而且要进行许多操作，那么使用spring的自动装配是很难完成的，所以spring的开发者把这些工作交给了我们。

42.ApplicationContext?
访问应用程序组件的Bean工厂方法。从org.springframework.beans.factory.ListableBeanFactory继承。
以通用方式加载文件资源的能力。继承自org.springframe .core.io。ResourceLoader接口。
向注册侦听器发布事件的能力。继承自ApplicationEventPublisher接口。
解析消息的能力，支持国际化。继承自MessageSource接口。

43.SpringAOP默认的动态代理是什么？区别是什么？
默认情况下，Spring会优先使用JDK动态代理。如果目标类没有实现任何接口，Spring才会退而求其次地使用CGLIB代理。
你可以通过配置强制Spring使用CGLIB代理，如在@EnableAspectJAutoProxy注解中设置proxyTargetClass=true，即使目标类实现了接口，Spring也会使用CGLIB代理。
JDK动态代理：适用于实现了接口的类，性能稍低。
CGLIB代理：适用于没有接口的类，性能稍高，但不支持final类。

44.简单讲一讲请求如何找到对应的Controller？
所有的HTTP请求首先都会被Spring的DispatcherServlet拦截。DispatcherServlet是Spring MVC的核心，它负责将请求分发给适当的处理器（通常是一个Controller）。
DispatcherServlet会利用一个或多个HandlerMapping来查找与当前请求路径对应的处理器（即Controller）。
HandlerMapping是Spring中的一个接口，它的实现类负责根据请求URL查找处理器。最常用的实现是RequestMappingHandlerMapping，它会根据@RequestMapping注解来匹配请求。
一旦DispatcherServlet确定了哪个处理器（即哪个Controller方法）应该处理当前请求，它会将这个处理器交给HandlerAdapter。
HandlerAdapter负责调用具体的Controller方法。它会处理方法参数的注入（比如@RequestParam、@PathVariable等），并在方法执行后，将返回值包装为一个ModelAndView对象。
如果Controller方法返回的是视图名称，DispatcherServlet会使用ViewResolver来解析视图并渲染页面。
如果返回的是数据（如JSON），HttpMessageConverter将负责将数据转换为相应的格式并返回给客户端。
总结：请求首先到达DispatcherServlet。DispatcherServlet通过HandlerMapping查找与请求URL匹配的Controller。
找到匹配的Controller方法后，HandlerAdapter负责调用该方法。返回视图或数据给客户端。

45.Spring 事务在什么情况下会失效？
如果目标方法不是 public，则TransactionAttribute返回 null，即不支持事务。
如果某个方法用 final 修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。注意：如果某个方法是 static 的，同样无法通过动态代理，变成事务方法。
在同一个类中的方法直接内部调用，会导致事务失效。
多线程调用
错误的事务传播特性

46.Spring 中的 @Profile 注解的作用是什么？
@Profile注解用于条件化地注册bean，基于所活动的环境配置文件(profiles)。一个环境配置文件对应于一组特定的应用配置，例如，你可能会有development、test和production不同的配置文件，每个配置文件针对不同的运行环境。
--------------------------------------------------------------------------------------------
《springMvc与springBoot》
1.请简述Spring MVC的五大组件 ？
DispatcherServlet:这个控件是SpringMVC最核心的一个控件，是Spring写好的一个Servlet
HandleMapping:控件标明了路径与Controller的对应关系，不同的路径访问不同的Controller
Controller用来处理业务逻辑的Java类
ModeAndView:Mode用来绑定处理后所得的数据，View视图名
ViewResolver:视图解析器明确了视图名与视图对象的关系，是调用demo.jsp还是调用demo.html,以及明确视图的位置

2.spring MVC中的前段控制器?
spring MVC中的前段控制器就是DsipatcherServlet,他继承了HttpServlet这个抽象类。

3.Spring MVC框架的优点？
Spring MVC采用了MVC（模型-视图-控制器）设计模式，通过将应用程序的不同层分离，实现了松耦合的架构，使得开发和维护变得更容易。

4.自定义拦截器？
自定义一个拦截器非常简单，只需要实现HandlerInterceptor这个接口即可，该接口有三个可以实现的方法：
preHandle()：该方法会在目标方法执行前执行，当其返回值为true时，表示继续向下执行；当其返回值为false时，会中断后续的所有操作(包括调用下一个拦截器和控制器类Controller中的方法执行等 )。
postHandle()： 该方法会在目标方法调用之后，且解析视图之前执行。可以通过此方法对请求域中的模型和视图作出进一步的修改。
afterCompletion()：该方法会在整个请求完成，即视图渲染结束之后执行。可以通过此方法实现一些资源清理、记录日志信息等工作。
想要在Spring Boot生效，只需要定义一个配置类，实现WebMvcConfigurer这个接口，并且实现其中的addInterceptiors()方法即可。

5.spring boot的starter是什么？
starter是依赖的集合
starter可以理解成pom配置了一堆jar组合的空maven项目，用来简化maven依赖配置，starter可以继承也可以依赖于别的starter。
starter使用注解自动配置的形式提供默认的配置，使开发项目更便捷。
starter负责配置固定的版本以及依赖的整合问题。

6.starter原理？
主要是基于它提供的起步依赖和自动配置。

7.Spring Boot是如何完成自动配置的呢？
自动配置涉及到如下几个关键步骤：基于Java代码的Bean配置。自动配置条件依赖。Bean参数获取。Bean的发现。Bean的加载

8.解释为什么需要spring-boot-maven-plugin？
方便地将Spring Boot应用程序打包为可执行的jar或war文件。
可以将所有依赖项打包到生成的jar或war文件中，从而使您的应用程序更加独立和可移植。

9.Spring Boot 热部署方式？
Spring DevTools：当修改代码后，应用程序会自动重新加载。
JRebel：可以实时更新代码和资源，无需重启应用程序。它能够在运行时修改类文件
Spring Loaded：当修改类文件后，Spring Loaded 会自动重新加载类，以便开发者能够立即看到修改的效果。
Docker + 文件挂载：使用 Docker 部署应用程序时，可以将应用程序的代码和资源文件挂载到容器中，实现实时更新代码而无需重启容器。

10.bootstrap和application的区别？
bootstrap配置文件比application配置文件优先加载，bootstrap是由Spring父上下文（父ApplicationContext）加载，application是由Spring子上下文加载。
bootstrap里的属性不能被覆盖，如果bootstrap和application两种类型的文件同时存在，是以bootstrap配置文件为主
bootstrap主要用于配置系统级别的一些参数一些固定的，不能被覆盖的参数，当你使用了Spring Cloud Config配置中心时，这时需要在boostrap配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息。
application用于配置一些应用级别的参数第三方数据源的配置rabbitmq,redis的配置。

11.SpringBoot是如何实现main方法启动Web项目的?
自动配置：SpringBoot会根据添加的依赖自动配置项目。例如，如果你在项目的pom.xml或build.gradle文件中添加了spring-boot-starter-web依赖，SpringBoot会自动配置与Web相关的组件，如DispatcherServlet、嵌入式Servlet容器（如Tomcat、Jetty等）等。
嵌入式Servlet容器：SpringBoot集成了嵌入式Servlet容器，这意味着你不需要将应用部署到外部的Servlet容器中，如Tomcat或Jetty。相反，你可以直接在应用中嵌入这些容器，并通过main方法启动它们。这是通过引入相应的starter依赖（如spring-boot-starter-tomcat）来实现的。
SpringApplication.run()方法：在main方法中，我们通过调用SpringApplication.run()方法来启动SpringBoot应用。这个方法会负责创建和初始化Spring上下文，配置嵌入式Servlet容器，并启动它。此外，它还会触发Spring的生命周期事件，使得各种自动配置的组件能够按照预期工作。

12.@SpringBootApplication 注解的作用是什么？
@SpringBootApplication注解：这个注解是SpringBoot的核心，它实际上是一个复合注解，包括了@Configuration、@EnableAutoConfiguration和@ComponentScan。这个注解告诉SpringBoot这是一个应用类，需要自动配置和扫描组件。

13.Spring Boot 是否可以使用 XML 配置 ?
可以，@ImportResource(locations={"classpath:application-bean.xml"})

14.SpringBoot 最大连接数及最大并发数是多少？
在SpringBoot2.7.10版本中内置Tomcat版本是9.0.73，SpringBoot内置Tomcat的默认设置如下：
Tomcat的最大连接数，默认是8192，Tomcat的最大线程数，默认是200，Tomcat的连接超时时间，默认是20s。

15.SpringBoot处理跨域请求的方法?
@CrossOrigin注解。
配置通过实现WebMvcConfigurer接口，重写addCorsMappings方法。
创建一个配置类，实现Filter接口，重写doFIlter方法。
在application.properties或application.yml中添加全局配置项

16.SpringBoot实现定时任务?
使用@Scheduled注解。@Scheduled注解用于指定方法或者类的某个方法为定时任务, 它可以使用cron表达式或者固定的时延来定义任务的执行时间。
通过实现SchedulingConfigurer接口，重写configureTasks方法，可以配置多个定时任务，并指定其执行时间。
使用@Async注解和@Scheduled和ThreadPoolTaskScheduler, 通过在定时任务方法上添加@Async注解，同时配合使用ThreadPoolTaskScheduler来配置线程池，实现多线程定时任务的异步执行。

17.@Conditional？
@Conditional注解是一个条件装配注解，主要用于限制@Bean注解在什么时候才生效。按需创建bean。

18.如何在 SpringBoot 启动时执行特定代码？有哪些方式？
使用@PostConstruct注解标注的方法：在你的组件中，你可以使用@PostConstruct注解来标注一个方法，这个方法会在类的构造函数调用之后、字段注入之后执行。
实现CommandLineRunner或ApplicationRunner接口：你可以实现CommandLineRunner或ApplicationRunner接口，并重写run方法。Spring Boot会在启动时调用这个方法。
--------------------------------------------------------------------------------------------
《mybatis》
1.resultType与resultMap的区别？
resultType是实体类，resultMap将数据库查出来的字段封装的一个任意的对象中。

2.动态sql?
<where><if test="supCode!=null">and supCode like #{supCode}</if></where>

3.#{name} 或 ${name} 的区别？
#{} : 对读取到的参数先使用?来占位，然后去预编译SQL，最后再将?替换为形参值。
${} : 直接替换读取到的形参值，没有预编译的过程。有sql注入风险。

4.通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？
Dao接口即Mapper接口。接口的全限名，就是映射文件中的namespace的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。
Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。
Mapper接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。Mapper 接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回。

5.Mybatis是如何进行分页的？
分页插件通过拦截 MyBatis 执行的 SQL 语句，在执行查询前自动添加分页参数，开发者只需配置插件并调用分页方法，无需手动编写分页 SQL。
引入依赖，配置PageInterceptor的bean,在代码中调用startPage方法。

6.MyBatis 如何获取自增主键的？
使用usegeneratedkeys=”true” keyproperty=”id”属性

7.延迟加载
使用延迟加载方法，先去查询简单的sql（最好单表，也可以关联查询），再去按需要加载关联查询的其它信息。
resultMap标签里面嵌套使用association、collection实现一对一及一对多的映射。
--------------------------------------------------------------------------------------------
《mysql》
1.如何通过shell登入mysql?
mysql -uroot -p登陆密码

2.MySQL中InnoDB支持的四种事务隔离级别？
Read uncommitted: 未提交读，事务中的修改，即使没有提交，对其他事务也是可见的。存在脏读
Read committed: 提交读，大多数数据库系统的默认隔离级别(MySQL不是), 一个事务从开始到提交之前，所做的修改对其他事务不可见。解决脏读，存在幻读和不可重复读
repeatable read: 可重复读，该级别保证在同一事务中多次读取同样记录的结果是一致的。解决脏读和不可重复读，理论上存在幻读，但是在InnoDB引擎中解决了幻读
Serializable：可串行化，强制事务串行执行。

3.InnoDB 存储引擎?
事务安全（ACID兼容）：InnoDB通过事务来确保数据的完整性和一致性。它支持事务的原子性、一致性、隔离性和持久性（ACID属性）。
行级锁：与MyISAM的表级锁定不同，InnoDB采用行级锁定，这提高了并发性能，减少了锁冲突。
外键约束：InnoDB支持外键约束，有助于维护数据的引用完整性。通过外键，可以确保相关数据之间的正确关系。
MVCC（多版本并发控制）：InnoDB使用MVCC技术，允许多个读者和写者并发访问数据，而不会相互干扰。
聚集索引：InnoDB的表数据按主键的顺序存储，这称为聚集索引。这种存储方式有助于快速检索数据。

4.explain分析sql慢查询 ?
explain select * from goods where goodsID = 1;

5.如何提高MySQL insert的性能？
批量插入数据（一条sql插入多条数据）
主键顺序插入，尽量选择使用AUTO_INCREMENT自增主键。
手动使用事务（因为mysql默认是autocommit的，这样每插入一条数据，都会进行一次commit；所以，为了减少创建事务的消耗，我们可用手工使用事务，即START TRANSACTION;insert 。。,insert。。 commit；即执行多个insert后再一起提交；一般1000条insert 提交一次）

6.sync_binlog和innodb_flush_log_at_trx_commit参数？   （binlog和redolog）
sync_binlog是控制binlog_cache刷新到磁盘binlog频率的，而innodb_flush_log_at_trx_commit是控制redo log buffer刷新到磁盘redolog频率的。sync_binlog=0，表示MySQL不控制binlog的刷新，由文件系统自己控制它的缓存的刷新。如果sync_binlog>0，表示每sync_binlog次事务提交，MySQL调用文件系统的刷新操作将缓存刷下去。最安全的就是sync_binlog=1了，表示每次事务提交，MySQL都会把binlog刷下去。这样的话，在数据库所在的主机操作系统损坏或者突然掉电的情况下，系统才有可能丢失1个事务的数据。所以sync_binlog=1保证了数据安全，但是性能最差。

7.Innodb是行锁，那什么时候会产生行锁，什么情况下会变成表锁？
一般情况下，innodb只对指定的行进行锁定，其他进程还是可以对表中的其他行进行操作的，因此，这时候innodb加的就是行锁；
但是，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”。

8.新创建的数据库，需要调整哪些参数？
调整两方面的参数，即调整操作系统的和数据库my.cnf的：
操作系统的参数:linux参数系统的默认参数很多都是很保守的，所以需要根据服务器性能将一些参数进行加大，如我会调整nofile（最大文件句柄数）和nproc（最大线程数），将其放到最大；我会将vm.swappiness设置为0，表示最大限度使用物理内存，然后才是 swap空间；我会将net.ipv4.tcp_tw_reuse 设置为1，表示将netstat中出现的TIME-WAIT状态的sockets重用到新的TCP连接上...等等
数据库的参数:对于mysql来说，my.cnf的参数调整非常重要，如果采用默认值，那么是很难发挥mysql性能的。一般我会特别关注innodb_buffer_pool这个值，该值一般设置为物理内存的70%,这样就可以把mysql的表和索引最大限度的load到内存中，从而使mysql数据库性能得到大的提升；另外，我还特别关注sync_binlog和innodb_flush_log_at_trx_commit这两个值的设置，具体含义见上；还有max_user_connections ，我一般将该值设置为2000；还有innodb_lock_wait_timeout，看程序是长连接还是短连接，一般我会设置为60秒；还有innodb_log_file_size ，这个值也设置的大一点，我一般设置的为500M或1G。

9.如果发现CPU，或者IO压力很大，怎么定位问题？
首先我会用top命令和iostat命令，定位是什么进程在占用cpu和磁盘io； 
如果是mysql的问题，我会登录到数据库，通过show full processlist命令，看现在数据库在执行什么sql语句，是否有语句长时间执行使数据库卡住；
执行show innodb engine status命令，查看数据库是否有锁资源争用；
查看mysql慢查询日志，看是否有慢sql；
找到引起数据库占用资源高的语句，进行优化，该建索引的建索引，索引不合适的删索引，或者根据情况kill掉耗费资源的sql语句等

10.描述MySQL中，索引，主键，唯一索引，联合索引的区别？
索引是一种特殊的文件（InnoDB数据表上的索引是表空间的一个组成部分），它们包含着对数据表里所有记录的引用指针。
普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。
普通索引允许被索引的数据列包含重复的值，如果能确定某个数据列只包含彼此各不相同的值，在为这个数据索引创建索引的时候就应该用关键字UNIQE把它定义为一个唯一所以，唯一索引可以保证数据记录的唯一性。
主键，一种特殊的唯一索引，在一张表中只能定义一个主键索引，逐渐用于唯一标识一条记录，是用关键字PRIMARY KEY来创建。
索引可以覆盖多个数据列，如像INDEX索引，这就是联合索引。
索引可以极大的提高数据的查询速度，但是会降低插入删除更新表的速度，因为在执行这些写操作时，还要操作索引文件。

11.如何用MySQL命令进行备份和恢复？
mysqldump -u root -p test > test.sql
mysql -u root -p test < test.sql

12.详细阐述MySQL联合索引?
联合索引是两个或更多个列上的索引。
对于联合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。
例如索引是key index (a,b,c). 可以支持a 、 a,b 、 a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。
利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。
复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。
如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。

13.mysql怎么实现的索引？
B+树实现的。一个索引就是一颗B+树。
非主键索引的叶子结点存的是主键的值。其他节点是索引的值。
主键索引的叶子结点存的是这一行的数据,其他节点是主键的值。

14.没有创建索引也会创建B+树吗？
主键是聚簇索引，所以会创建。 其他索引是非聚簇索引。

15.B树和B+树的区别？
B树的非叶子结点即存这一行的数据，又存索引。
B树的非叶子结点只存索引，叶子结点才存这一行的数据和索引。

16.覆盖索引？
通过索引能查到要查的数据，就是覆盖索引，就不需要通过id去回表查询。

17.为什么非聚簇索引叶子结点为什么不存地址值而是存id?
因为地址值有可能会发生变化

18.联合，组合，复合索引？
两个列一起创建的索引，最左前缀法则。

19.什么情况会导致索引失效？
使用函数。 以%或_开头匹配。不等于也会失效。不符合最左前缀法则。

20.事务隔离级别？
读未提交（Read Uncommitted）
这个级别就像是没有隔音墙的房间，外面的噪音（其他请求对数据的修改）都能听到。在这个隔离级别下，一个事务可以读取到其他事务还没提交的数据。这就像是你在和别人说话时，突然有第三个人插话，你可能会听到一些不完整或错误的信息。这种级别可能会导致“脏读”问题，即读取到其他事务未提交的数据。
读已提交（Read Committed）
这个级别就像是有一层薄薄的隔音墙，只能隔绝部分噪音。在这个隔离级别下，一个事务只能读取到其他事务已经提交的数据。这就像是你在房间里说话，只有等别人说完后，你才能听到完整的话。这种级别避免了“脏读”问题，但可能会导致“不可重复读”问题。也就是说，在同一个事务中多次读取同一数据，结果可能不一致，因为其他事务可能已经修改了该数据。
可重复读（Repeatable Read）
这个级别就像是有较厚的隔音墙，能隔绝大部分噪音。在这个隔离级别下，一个事务在执行期间多次读取同一数据，结果总是一致的。这就像是你在房间里放音乐，无论外面多吵，你听到的音乐都是清晰的。这种级别解决了“不可重复读”问题，但可能会导致“幻读”问题。也就是说，在同一个事务中执行相同的查询，可能会得到不同的结果集，因为其他事务可能插入了新的数据。
串行化（Serializable）
这个级别就像是完全密封的房间，外面的噪音一点都听不到。在这个隔离级别下，事务会排队执行，就像一个个按顺序进入房间的人一样。这确保了每个事务在执行时都不会受到其他事务的干扰。这种级别避免了所有并发访问问题，但执行效率可能会较低，因为事务需要等待其他事务完成后才能执行。

21.什么是MVCC?
代表多版本并发控制。与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。
MVCC最大的优势：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的。

22.MySQL锁类型？
共享锁(Shared Locks)：也称为读锁(Read Locks)。允许多个会话同时获取共享锁，以进行读取操作。其他会话可以同时获取共享锁，但不能获取独占锁。共享锁之间不互斥。
独占锁(Exclusive Locks)：也称为写锁(Write Locks)。只有一个会话可以获取独占锁，以进行写入操作。独占锁会阻止其他会话获取共享锁或独占锁，确保数据的独占性。
表级锁(Table-level Locks)：表级锁作用于整个表，而不是表中的特定行或记录。表级锁包括共享锁和独占锁。使用表级锁可能会导致并发性较低，因为锁定整个表会阻止其他会话访问该表的不同部分。
行级锁(Row-level Locks)：行级锁允许在表中的特定行或记录上设置锁。可以使用行级锁来实现更高的并发性，因为不同的会话可以同时锁定表中的不同行。
间隙锁(Gap Locks)：间隙锁用于锁定某个范围内的数据，而不是具体的行。用于防止其他会话在某个范围内插入新数据，从而确保查询的一致性。主要用于防止幻读(Phantom Read)。

23.什么情况下会触发全局锁？
在进行数据库备份时，为了确保备份数据的完整性和一致性，通常需要获取全局锁。
在进行数据库软件升级或数据迁移时，可能需要锁定整个数据库以防止数据更改。
某些全局操作，如数据库重置、全局数据清理等，可能需要获取全局锁。

24.悲观锁和乐观锁？
悲观锁是一种保守的锁策略，它假设并发访问会导致冲突，并且默认情况下假定其他事务会修改数据。因此，悲观锁在读取数据之前会先锁定它，以防止其他事务对数据进行修改。悲观锁的工作原理如下：当一个事务要读取或修改某个数据时，它会先对该数据加锁。如果其他事务也要对该数据进行读取或修改操作，它们必须等待锁的释放。悲观锁的应用场景包括：高并发写入场景，如订单库存扣减。数据库中的行级锁。悲观锁的优点是简单易懂，适用于并发写入场景。然而，它也存在一些缺点：锁的开销较大，会降低系统的并发性能。长时间持有锁可能导致其他事务等待时间过长。
乐观锁是一种乐观的锁策略，它假设并发访问不会导致冲突，只在提交时检查是否有冲突。乐观锁的工作原理如下：当一个事务要读取某个数据时，它会记录下当前数据的版本号或时间戳。当事务要提交修改时，它会检查记录的版本号或时间戳是否与数据库中的数据一致。如果一致，事务可以提交；如果不一致，事务会回滚。乐观锁的应用场景包括：并发读取场景，如商品库存查询。乐观锁适用于多读少写的场景。乐观锁的优点是并发性能较高，不需要加锁操作。然而，它也存在一些缺点：需要记录版本号或时间戳，可能会增加存储和计算的开销。可能会出现冲突，需要处理冲突的情况。

25.union all和union
union all只是合并查询结果，union会额外进行去重和排序操作，在没有去重的前提下，使用union all的执行效率要比union高。

26.inner join，left join，right join 有什么区别？
INNER JOIN（内连接）：只返回两个表中匹配的行，即只返回连接条件为真的行。如果一个表中的行没有匹配，那么这些行不会出现在结果中。
LEFT JOIN（左连接）：返回左边表中的所有行，以及与右边表匹配的行，如果右边表中没有匹配的行，则返回NULL。
RIGHT JOIN（右连接）：返回右边表中的所有行，以及与左边表匹配的行，如果左边表中没有匹配的行，则返回NULL。
因此，INNER JOIN只返回两个表中匹配的行，LEFT JOIN返回左边表的所有行以及与右边表匹配的行，RIGHT JOIN返回右边表的所有行以及与左边表匹配的行。

27.MySQL 中的数据排序是怎么实现的？
排序过程中，如果排序字段命中索引，则利用索引排序。反之，使用文件排序。
文件排序中，如果数据量少则在内存中排序，具体是使用单路排序或者双路排序。如果数据大则利用磁盘文件进行外部排序，一般使用归并排序。

28.MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？
count(*) count(1) 会统计表中所有行的数量，包括  null 值（不会忽略任何一行数据）。由于只是计算行数，不需要对具体的列进行处理，因此性能通常较高。
count(字段名)不包括  null 值。

29.mysql基础
数据库约束：默认约束，非空约束，唯一约束等（加在数据库表字段）。
外键（foreign key）约束： 用于两张表之间建立连接。有外键的表叫做子表，被关联的表叫父表。 
外键行为：删除或更新父表中被关联的外键，默认是不允许的。
cascade：父表更新了，子表同样更新。
set null模式：父表更新了，子表设为null。
多表关系：
一对一关系：用户与用户详情的关系。常用于单表的拆分。和一对多关系的区别就是外键设置为唯一约束。
一对多关系：员工与部门的关系（一个员工只能有一个部门），在多(子表)的一方建立外键，关联一(父表)的那方的主键，多的那方叫子表，一的那方叫父表 
多对多关系：学生（主表）与课程（主表）关系（一个学生可以有多个课程）， 建立第三张表（子表）里面维护两个外键，分别是学生表的主键和课程表的主键。
多表查询：添加连接条件（子表的外键等于父表的主键）消除无效笛卡尔积。 
连接查询：
内连接是查询两表交集的部分。这个交集指的是两张表的外键和主键有确定关系的部分。
左外连接：左表全部和两表交集部分。右外连接：右表全部和两表交集部分。
自连接（单表的连接查询）：当前表与自身连接查询，必须使用表别名。 常用于一张表中的树形数据。 
显示内连接：a join b on 连接条件 a left join b on 连接条件 
联合查询：sql a union sql b 将两个查询结果合并起来，形成一个新的查询结果集。
子查询（嵌套查询）：sql语句的where条件里还有select称为嵌套查询。
sql执行顺序 from, join, where, group by,having, select, distinct, order by, limit
--------------------------------------------------------------------------------------------
《redis》
1.




--------------------------------------------------------------------------------------------
《rabbitmq》
1.AMQP协议的基本概念？
生产者Publisher：生产消息，就是投递消息的一方。
消费者Consumer：消费消息，也就是接收消息的一方。
Broker服务节点：表示消息队列服务器实体。一般情况下一个Broker可以看做一个RabbitMQ服务器。
Queue：消息队列，用来存放消息。一个消息可投入一个或多个队列，多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。
Exchange：交换器，接受生产者发送的消息，根据路由键将消息路由到绑定的队列上。
Routing Key：路由关键字，用于指定这个消息的路由规则，需要与交换器类型和绑定键(Binding Key)联合使用才能最终生效。
Binding：绑定，通过绑定将交换器和队列关联起来，一般会指定一个BindingKey，通过BindingKey，交换器就知道将消息路由给哪个队列了。
Connection ：网络连接，比如一个TCP连接，用于连接到具体broker
Channel： 信道，AMQP 命令都是在信道中进行的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接，一个TCP连接可以用多个信道。客户端可以建立多个channel，每个channel表示一个会话任务。

2.SpringBoot如何整合Rabbitmq?
导入spring-boot-starter-amqp的包
编写config配置类,配置相关交换机,队列,绑定键
利用@RabbitListener(要绑定的队列)+ @RabbitHandler 比如前一个注解标注在类上,后一个注解标注在方法上,用来监听某一个队列后,一旦队列有消息就做出相应操作
注入RabbitmqTemplate组件,然后利用相应的api进行发送消息,比如convertAndSend()方法
在处理订单超时这种情况便是如上方案: 先配置好队列的过期时间,一旦生成订单的消息在消息队列里没有被消费,那么这个时候就会被放入到死信队列里面,这个时候,我们就可以监听这个死信队列,一旦死信队列里面产生了消息,就执行dao的方法将相应的订单消息删除.
其次,如果你想保证消息的可靠性传输,可以设置应答机制和返回机制,利用rabbtemplate里的setConfirmCallback和setReturnCallback方法,前者是在消息成功到达之后会返回一个回调,后者是消息没有成功到达会返回一个回调,最后利用@PostConstruct让这两个机制发生在容器初始化的时候被调用就可以了。